<title>729</title>

<div id="container">
<canvas id="tileCanvas"></canvas>
<canvas id="bgtileCanvas"></canvas>
<canvas id="arrowCanvas"></canvas>
<canvas id='background'></canvas>

<div id="title">
<h1>729</h1>
</div>

<!-- Login/User Info -->
<div id="authContainer" style="position:absolute; top:2%; right:2%; z-index:100;">
    <button id="loginBtn" onclick="saveGameState(); loginWithDiscord();" style="display:none; background:#5865F2; color:#fff; border:none; padding:12px 24px; border-radius:8px; cursor:pointer; font-size:18px;">Login with Discord</button>
    <div id="userInfo" style="display:none; background:rgba(0,0,0,0.7); color:#fff; padding:8px 12px; border-radius:8px; font-size:14px;">
        <span id="username"></span>
        <button onclick="logoutUser()" style="margin-left:10px; background:#666; color:#fff; border:none; padding:4px 8px; border-radius:4px; cursor:pointer; font-size:12px;">Logout</button>
    </div>
</div>

<!-- Leaderboard Link -->
<div style="position:absolute; top:2%; left:2%; z-index:100;">
    <a href="leaderboard.html" onclick="saveGameState()" style="background:#8CB84A; color:#282828; padding:12px 24px; border-radius:8px; text-decoration:none; font-size:18px; font-weight:bold;">üèÜ Leaderboard</a>
</div>

<!-- Version Number -->
<div style="position:absolute; bottom:2%; right:2%; z-index:100; color:#999; font-size:10px; opacity:0.5;">v1.5.1</div>

<div id ="instructions">
<p>Line up three matching numbers and swipe them together. Get a <b>729</b> tile to win.</p>
</div>
<div id ="gameOver">
    <div id ="inner1">
        <p>Game over! Your score is 0.</p>
    </div>
    <div id="gameOverSubmissionStatus" style="display:none; margin:10px 0; padding:10px; background:rgba(140,184,74,0.2); border-radius:8px; font-size:14px;"></div>
    <div id="gameOverLoginPrompt" style="display:none; margin:10px 0; color:#666; font-size:14px;">
        <p>Login to save your high score!</p>
    </div>
<button onclick="newGame()" class="button">New Game</button>
<button onclick="toClipboard(true)" class="button3">Share (clipboard)</button>
<button id="gameOverLoginBtn" onclick="saveGameState(); showLoginOptions('gameOver');" class="button" style="display:none;">Claim Your Score</button>
</div>

<div id ="youWin">
    <div id ="inner2">
        <p">You won!</p>
    </div>
    <div id="winTimeDisplay" style="margin:10px 0; font-size:16px;"></div>
    <div id="winLoginPrompt" style="display:none; margin:10px 0; color:#666; font-size:14px;">
        <p>Login to submit your time!</p>
    </div>
<button onclick="continueGame()" class="contButton">Continue?</button>
<button onclick="toClipboard(false)" class="button3">Share (clipboard)</button>
<button id="winLoginBtn" onclick="saveGameState(); showLoginOptions('win');" class="button" style="display:none;">Claim Your Time</button>
</div>

<div id ="score" onclick="toggleScore()">
    <p">Score: </p>
</div>

<!-- Login Options Modal -->
<div id="loginOptionsModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; justify-content:center; align-items:center;">
    <div style="background:#282828; padding:30px; border-radius:16px; max-width:400px; text-align:center; color:#fff;">
        <h2 style="margin:0 0 20px 0; color:#8CB84A;">Claim Your Score</h2>
        <p style="color:#999; margin-bottom:30px;">Choose how you'd like to claim your score:</p>

        <button onclick="loginWithDiscord(); closeLoginOptions();" style="width:100%; background:#5865F2; color:#fff; border:none; padding:16px; border-radius:8px; cursor:pointer; font-size:16px; font-weight:bold; margin-bottom:12px;">
            Login with Discord
        </button>

        <div style="margin:20px 0; color:#666;">‚Äî or ‚Äî</div>

        <div id="nameInputSection">
            <input type="text" id="displayNameInput" placeholder="Enter your name (3-20 chars)" maxlength="20" style="width:100%; padding:12px; border:2px solid #444; border-radius:8px; background:#1a1a1a; color:#fff; font-size:16px; margin-bottom:12px; box-sizing:border-box;">
            <button onclick="claimWithName();" style="width:100%; background:#8CB84A; color:#282828; border:none; padding:16px; border-radius:8px; cursor:pointer; font-size:16px; font-weight:bold; margin-bottom:12px;">
                Just Use This Name
            </button>
        </div>

        <button onclick="closeLoginOptions();" style="width:100%; background:#444; color:#fff; border:none; padding:12px; border-radius:8px; cursor:pointer; font-size:14px; margin-top:10px;">
            Cancel
        </button>
    </div>
</div>

<meta name="viewport" content="user-scalable=no">

<button onclick="newGame()" class="button2"> New Game </button>

</div>

<link rel="stylesheet" href="fonts/stylesheet1.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="fonts/kit2/stylesheet.css" type="text/css" charset="utf-8" />

<style>

//     top: 68%;
//    left: 5%;
//    right: 52%;
//    margin: 2vw;
//    font-size: 5.5vw;

// z index notes: https://css-tricks.com/forums/topic/safari-for-ios-z-index-ordering-bug-while-scrolling-a-page-with-a-fixed-element/

* {
    overflow:hidden
    touch-action: none
    box-sizing: border-box
} 

html {
  height: 100%;
  width: 100%;
  overflow: hidden;
  -webkit-overflow-scrolling: auto;
}

#twitter-widget-0{

    position:absolute; 
    right:13% !important;
    top:87% !important;
    z-index:50 !important;
    border: 0px none ; 
    padding: 0px; 
    height:30vw "

}

body { 

    top:0;
    left:0;
    //position: fixed;

  height: 100%;
  scrollHeight: 100%;
  padding: 0;
  overflow: hidden;
  margin: 0;
  -webkit-overflow-scrolling: auto;
	font-family: 'OmegleRegular';					

    //overscroll-behavior: contain;

    //   margin: 0; 
    //   padding: 0
    //}
#container{


    -webkit-overflow-scrolling: auto;
    height:100% -1px; overflow:hidden;
    max-width: 66vh;
    margin: 0 auto;
}

#tileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#bgtileCanvas { 
     background-color: #222529;
     position: absolute;
     left: 0;
     top: 0;
     z-index: -1;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#arrowCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#title {
    position: absolute;
    top: -3%;
    left: 0;
    right: 0;
    margin: 0;//auto;
    z-index: 100;
    font-size: 13vw;
    color: #D1D2D3;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    text-shadow: -4px -4px 0 #000, 4px -4px 0 #000, -4px 4px 0 #000, 4px 4px 0 #000;
    user-select: none;
}
#instructions {  

    position: absolute;
    top: 78%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 4vw;
    z-index: 100;
    color: #D1D2D3;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    user-select: none;
}
#twitterDesc {  

    position: absolute;
    top: 88%;
    left: 15%;
    right: 0;
    margin: auto;
    font-size: 2vw;
    //display: inline-block;
    //vertical-align: middle;
    //text-align: center;
    user-select: none;
}
#gameOver {

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;

    display: none;

    z-index: 200;
    background-color:#D1D2D3;
    position: absolute;
    top: 40%;
    left: 20%;
    right: 20%;
    margin: auto;
    font-size: 4vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
    user-select: none;
}

#youWin {

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;

    display: none;

    z-index: 200;
    background-color:white;
    position: absolute;
    top: 40%;
    left: 20%;
    right: 20%;
    margin: auto;
    font-size: 4vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
    user-select: none;
}
.button {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    z-index: 50;
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    border: none;
    color: rgb(40, 40, 40);;
    padding: 2vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'OmegleRegular';
    font-size: 4vw;
    user-select: none;
}

.button2 {  
    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    z-index: 50;
    color: rgb(40, 40, 40);
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    position: absolute;
    text-decoration: none;
    top: 70%;
    left: 52%;
    right: 5%;
    margin: 2vw;
    font-family: 'OmegleRegular';
    font-size: 5.5vw;
    vertical-align: middle;
    text-align: right;
    user-select: none;
}
.button3 {  

    border-radius: 1.5vw;
    border: 1vw solid #000000;
    padding: 1.5vw;
z-index: 50;
background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
border: none;
color: rgb(40, 40, 40);
padding: 2vw;
text-align: center;
text-decoration: none;
display: inline-block;
font-family: 'OmegleRegular';
font-size: 4vw;
user-select: none;
}
.contButton {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    z-index: 50;
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    border: none;
    color: rgb(40, 40, 40);;
    padding: 2vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'OmegleRegular';
    font-size: 4vw;
    user-select: none;
}
#score {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    z-index: 50;
    background-color:#D1D2D3;
    position: absolute;
    top: 70%;
    left: 5%;
    right: 52%;
    margin: 2vw;
    font-size: 5.5vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;
    user-select: none;
   
}
#reset {   /* I don't think this element actually exists try to remove later one thing at a time for now*/

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 0vw;
    
    display: inline-block; 
    
    background-color: black; /* #4CAF50;  Green */
    position: absolute;
    top: 71%;
    left: 52%;
    right: 5%;
    margin: auto;
    font-size: 5vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;
    user-select: none;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/sketch-js@1.1.3/js/sketch.min.js"></script>

<script>
// https://gist.github.com/joates/6584908
function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}
var angles = linspace(0,Math.PI * 2, 7)
var slice  = Math.PI / 6
function mod(n, m) {
        return ((n % m) + m) % m;
}

// colR1, colR2, colR3, colR4, colR5, colG1, colG2, colG3, colG4, colG5, colB1, colB2, colB3, colB4, colB5
// R is E-Z direction, smaller values E, larger values Z
// G is A-D direction, smaller values D, larger values A
// B is W-X direction, smaller values X, larger values W

// need to get cols depending on direction

var count = 0 


// case 0 [7, 1, 2, 11]] ( this isn't right )  (direction W)
// postion 15, col G2 coming up

var colR1  = [12,13,14]
var colR2  = [11,3,4,15]
var colR3 = [10,2,0,5,16]
var colR4  = [9,1,6,17]
var colR5  = [8,7,18]

var colG1  = [10,11,12]
var colG2  = [9,2,3,13]
var colG3 = [8,1,0,4,14]
var colG4  = [7,6,5,15]
var colG5  = [18,17,16]

var colB1  = [8,9,10]
var colB2  = [7,1,2,11]
var colB3 = [18,6,0,3,12]
var colB4  = [17,5,4,13]
var colB5  = [16,15,14]

var e_z_cols = [[colR3,2],[colR4,3],[colR3,2],[colR2,1],[colR2,1],[colR3,2],[colR4,3],[colR5,4],[colR5,4],[colR4,3],[colR3,2],[colR2,1],[colR1,0],[colR1,0],[colR1,0],[colR2,1],[colR3,2],[colR4,3],[colR5,4]]
var a_d_cols = [[colG3,2],[colG3,2],[colG2,1],[colG2,1],[colG3,2],[colG4,3],[colG4,3],[colG4,3],[colG3,2],[colG2,1],[colG1,0],[colG1,0],[colG1,0],[colG2,1],[colG3,2],[colG4,3],[colG5,4],[colG5,4],[colG5,4]]
var w_x_cols = [[colB3,2],[colB2,1],[colB2,1],[colB3,2],[colB4,3],[colB4,3],[colB3,2],[colB2,1],[colB1,0],[colB1,0],[colB1,0],[colB2,1],[colB3,2],[colB4,3],[colB5,4],[colB5,4],[colB5,4],[colB4,3],[colB3,2]]



var colList = [] 

var values     = new Array(19).fill(0)
var nextValues = new Array(19).fill(0)
var slides     = new Array(19).fill(0)
var pops       = new Array(19).fill(0)

var prompt = false
var won    = false

var slideValue  = []
var slide       = false
var update      = true
var first       = true  // keep animating before the first move to load the font
    
var actionQueue = []
    
var slideStartX = []
var slideStartY = []
    
var deltaX = []
var deltaY = []
    
var steps = 30
var step  = 0
var games = 0

// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
// Modified to expose internal state for save/restore
var time = Math.round((new Date()).getTime() / 1000);

var rngState = {
    seed: time,
    current: time
};

function initRNG(seed) {
    rngState.seed = seed;
    rngState.current = seed;
}

function rand() {
    rngState.current = Math.imul(48271, rngState.current);
    return (2**31-1 & rngState.current) / 2**31;
}

var gameRecord = {'time': time,
                   'moves' : []}

// ctx is the context to add the path to
// points is a array of points [{x :?, y: ?},...
// radius is the max rounding radius 
// this creates a closed polygon.
// To draw you must call between 
//    ctx.beginPath();
//    roundedPoly(ctx, points, radius);
//    ctx.stroke();
//    ctx.fill();
// as it only adds a path and does not render. 
function roundedPoly(ctx, points, radiusAll) {
  var i, x, y, len, p1, p2, p3, v1, v2, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut,radius;
  // convert 2 points into vector form, polar form, and normalised 
  var asVec = function(p, pp, v) {
    v.x = pp.x - p.x;
    v.y = pp.y - p.y;
    v.len = Math.sqrt(v.x * v.x + v.y * v.y);
    v.nx = v.x / v.len;
    v.ny = v.y / v.len;
    v.ang = Math.atan2(v.ny, v.nx);
  }
  radius = radiusAll;
  v1 = {};
  v2 = {};
  len = points.length;
  p1 = points[len - 1];
  // for each point
  for (i = 0; i < len; i++) {
    p2 = points[(i) % len];
    p3 = points[(i + 1) % len];
    //-----------------------------------------
    // Part 1
    asVec(p2, p1, v1);
    asVec(p2, p3, v2);
    sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    angle = Math.asin(sinA);
    //-----------------------------------------
    radDirection = 1;
    drawDirection = false;
    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }
    if(p2.radius !== undefined){
        radius = p2.radius;
    }else{
        radius = radiusAll;
    }
    //-----------------------------------------
    // Part 2
    halfAngle = angle / 2;
    //-----------------------------------------

    //-----------------------------------------
    // Part 3
    lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    //-----------------------------------------

    //-----------------------------------------
    // Special part A
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }
    //-----------------------------------------
    // Part 4
    x = p2.x + v2.nx * lenOut;
    y = p2.y + v2.ny * lenOut;
    //-----------------------------------------
    // Part 5
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    //-----------------------------------------
    // Part 6
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    //-----------------------------------------
    p1 = p2;
    p2 = p3;
  }
  ctx.closePath();
}


var direction_select = -1
var arrow_hint_intensity = 0
var arrow_hint_intensity_2 = 0




function draw_arrow(x, y, direction, ctx){

    unfuck_arrow_list = [4,3,2,1,0,5] // I think because I already hardcoded something else, now I just need to hardcode this, or unhardcode the other thing first

    direction = unfuck_arrow_list[direction]

    //console.log("arrow:" + (mod((angles[direction] + slice),2*Math.PI)))

    var points = []

    var size = .01 + circleSize * Math.max(arrow_hint_intensity,arrow_hint_intensity_2)
    //console.log(direction)
    //console.log(size)

    var angle_primary = angles[direction] - slice
    var angle_slant_1 = angle_primary - Math.PI/2 - Math.PI/8
    var angle_slant_2 = angle_primary + Math.PI/2 + Math.PI/8


    ret = offsetExact2(x,y, angle_primary, size/6 + circleSize/6)
    var firstX = ret[0]
    var firstY = ret[1]
    points.push({x: firstX,y: firstY})
    ret = offsetExact2(firstX,firstY, angle_slant_1, 2*size/8)
    var cornerX = ret[0]
    var cornerY = ret[1]
    points.push({x: cornerX,y: cornerY})
    ret = offsetExact2(firstX,firstY, angle_slant_2, 2*size/8)
    var cornerX = ret[0]
    var cornerY = ret[1]
    points.push({x: cornerX,y: cornerY})

    ah2 = arrow_hint_intensity_2 * .6
    ctx.strokeStyle = 'black'
    //if(isSafari){
    //    ctx.lineWidth = 1
    //    if(value != 0){
    //        ctx.lineWidth += 2
    //    }
    //} else {
    //    ctx.lineWidth = 3
    //}
    ctx.beginPath()
    //console.log(points)
    roundedPoly(ctx, points, size/64)
    ctx.stroke()
    //console.log('hsl(60,'+(50+ah2)+'%,'+(ah2*2)+'%)')
    if(arrow_hint_intensity_2 > 0){
        ctx.fillStyle = 'hsl(60,'+(50+ah2*50)+'%,'+(ah2*100)+'%)'
        ctx.fill()
    }

}

function hexagon(x, y, ctx, value){
   
    var fill = false

    if(value != 0){
        fill = true
    }
   
    ret = offset2(x, y, 0 , circleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]

    var points = []
    
    //points.push({x: ret[0],y: ret[1]})
    
    //points.push

    var yTop = cornerY
    var yBot = cornerY - circleSize/2

    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]

        //if(cornerY > yTop){yTop = cornerY}
        //if(cornerY < yTop){yBot = cornerY}
        
        points.push({x: ret[0],y: ret[1]})
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }

    colors = getColor(value)

    var gradient = ctx.createLinearGradient(0,yTop,0,yBot)
    //gradient.addColorStop(0,"rgba(0,0,0,1)")//colors[0])
    gradient.addColorStop(0,colors[1])
    gradient.addColorStop(1,colors[0])

    ctx.fillStyle = gradient
    
    //ctx.fillStyle = 'black'
    
    //console.log(points)
    
    
    
    ctx.strokeStyle = 'black'
    
    if(isSafari){
        ctx.lineWidth = 1
        
        if(value != 0){
            ctx.lineWidth += 2
        }
    } else {
        ctx.lineWidth = 3
        
        if(value != 0){
            ctx.lineWidth += 6
        }
    
    }
    ctx.beginPath()

    roundedPoly(ctx, points, circleSize/8)

    ctx.fill()
    
    //if(value != 0){
    ctx.stroke()
    //}

    
    //if(mod(value,2) == 0 && value != 0){
    //    ctx.fillStyle = "#000000"
    //}
    
    //console.log(getColor(value))
    //console.log(getColorInv(value))
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = getColorInv(value)[0]; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()

}

function towards(x1,y1,x2,y2,distance){

    var diffX = x2 - x1
    var diffY = y2 - y1

    var mag = Math.sqrt(diffX*diffX + diffY*diffY)
    var outX = x1 + diffX * distance / mag
    var outY = y1 + diffY * distance / mag
    
    return [outX,outY]
}

// these two use the angle number to look up the exact angle from the angles list
function offset(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle] + slice)) * factor
    retY = y + (Math.cos(angles[angle] + slice)) * factor
    
    return [retX,retY]
}
function offset2(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle])) * factor
    retY = y + (Math.cos(angles[angle])) * factor
    
    return [retX,retY]
}
// this one uses the angle in radians instead of a lookup index
function offsetExact(x, y, angle, factor){
    retX = x + (Math.sin(angle + slice)) * factor
    retY = y + (Math.cos(angle + slice)) * factor
    
    return [retX,retY]
}
// this one uses the angle in radians instead of a lookup index
function offsetExact2(x, y, angle, factor){
    retX = x + (Math.sin(angle)) * factor
    retY = y + (Math.cos(angle)) * factor
    
    return [retX,retY]
}

var score = 0

// these are not in order sorry. background < bgtile < tile < arrow

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");
var canvas4 = document.getElementById("background");
var ctx4    = canvas4.getContext("2d");


var userAgent = window.navigator.userAgent;
var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))

var height = null
var width  = null

/*
if( window.innerHeight < screen.height){
    height = window.innerHeight
} else {
    height = screen.height
}
if( window.innerWidth < screen.width){
    width = window.innerWidth
} else {
    width = screen.width
}*/

var min = width

var circleSize = width / 5
var directions = [2,3,4,5,0,1]
var posX = []
var posY = []

var fontSize = circleSize/2.5

var smoke = false
var smokeFrame = 0

ctx1.font= fontSize.toString() + 'px OmegleRegular';
ctx2.font= fontSize.toString() + 'px OmegleRegular';
ctx3.font= fontSize.toString() + 'px OmegleRegular';

var score      = 0
var startTime  = 0
var startDate  = Date.now()

var displayTime = false

var scoreDiv = document.getElementById("score");
scoreDiv.innerText ="Score: " + score.toString()

function initCanvas(){

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");
var canvas4 = document.getElementById("background");
var ctx4    = canvas4.getContext("2d");

    var userAgent = window.navigator.userAgent;
    var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))
    if (isSafari){
    

        height = screen.height *.9//window.innerHeight
        width = screen.width//window.innerWidth


        ctx1.canvas.width  = screen.width//window.innerWidth  -1; //width//
        ctx1.canvas.height = screen.height *.9//window.innerHeight -1; //height//
        ctx2.canvas.width  = screen.width //window.innerWidth  -1; // width//
        ctx2.canvas.height = screen.height *.9//window.innerHeight -1; // height//
        ctx3.canvas.width  = screen.width//window.innerWidth  -1;  // width//
        ctx3.canvas.height = screen.height *.9//window.innerHeight -1; // height//
        ctx4.canvas.width  = screen.width//window.innerWidth  -1;  // width//
        ctx4.canvas.height = screen.height *.9//window.innerHeight -1; // height//
    } else {
        height = window.innerHeight *.9
        width = window.innerWidth

        ctx1.canvas.width  = window.innerWidth  ; //width//
        ctx1.canvas.height = window.innerHeight *.9; //height//
        ctx2.canvas.width  = window.innerWidth  ; // width//
        ctx2.canvas.height = window.innerHeight *.9; // height//
        ctx3.canvas.width  = window.innerWidth  ;  // width//
        ctx3.canvas.height = window.innerHeight *.9; // height//
        ctx4.canvas.width  = window.innerWidth  ;  // width//
        ctx4.canvas.height = window.innerHeight *.9; // height//
    
    }
    
        //console.log(height)
        //console.log(width)
    
    canvas3.style.zIndex = 40
    canvas1.style.zIndex = 30    // wooooow fuck that everything online had a dash in z-index for the css but it didn't actually have a dash
    canvas2.style.zIndex = 20
    canvas4.style.zIndex = 10

    //https://www.quirksmode.org/dom/w3c_cssom.html 
    //console.log(angles)
    //console.log(slice)

    var canvasLeft = canvas1.offsetLeft;
    var canvasTop  = canvas1.offsetTop;
    var count = 0

    
    min = width
    
    ratio = width / height
    //console.log(ratio)
    
    if(width+400 > height){
    
        ratio = (width / height) * 2 // seems about right
        // elements that need font prop change
        // #reset {  #score {  .contButton {  .button2 {  .button {   #youWin {  #gameOver {   #instructions {  #title
        min = width / ratio
        
        var resizes = []

        //resizes.push(document.getElementById('reset'))
        resizes.push(document.getElementById('score'))
        resizes.push(document.getElementsByClassName("contButton")[0])
        resizes.push(document.getElementsByClassName('button2')[0])
        resizes.push(document.getElementsByClassName('button')[0])
        resizes.push(document.getElementById('youWin'))
        resizes.push(document.getElementById('gameOver'))
        resizes.push(document.getElementById('instructions'))
        resizes.push(document.getElementById('title'))
        // Removed twitterDesc, twitlinkPic, paypalImg - elements no longer exist
        resizes.push(document.getElementsByClassName('button3')[0])
        
        //console.log(resizes)
        
        for(var i = 0; i < resizes.length; i++){
        
            oldSize = parseFloat(getComputedStyle(resizes[i])['font-size'])
            resizes[i].style.fontSize  = (oldSize / ratio).toString() + 'px'
            //console.log(getComputedStyle(resizes[i]))
            
        }
        
        // this is all janky but idk the better way to do it yet

        var scoreStyle    = resizes[0].style
        var restartStyle  = resizes[2].style
        var instructions  = resizes[6].style
        // Removed twitDesc, twitPic, paypalImg references

        scoreStyle.position   = 'absolute'
        restartStyle.position = 'absolute'
        instructions.position = 'absolute'

        scoreStyle.left     = '27%'
        restartStyle.right  = '20%'

        scoreStyle.top     = '63%'
        restartStyle.top   = '63%'

        scoreStyle.border    = '.2vw solid #000000'
        restartStyle.border  = '.2vw solid #000000'

        // Removed styling for Twitter and PayPal elements

        instructions.top = '80%'
        
    } else{
        scale = ratio

        title = document.getElementById('title')

        scale = scale * 10
        font_s = 17 - scale
        title.style.fontSize = font_s + "vw"
    }
    
    if(isSafari){
        circleSize = Math.floor(min / 5.4)
        var drawX = width/2//520
        var drawY = height*.4  //520
    }
    else {
        circleSize = Math.floor(min / 5)
        var drawX = width/2//520
        var drawY = height*.4  //520
    }
    
    directions = [2,3,4,5,0,1]
    
    fontSize = circleSize/2.5

    ctx1.font= fontSize.toString() + 'px OmegleRegular';
    ctx2.font= fontSize.toString() + 'px OmegleRegular';
    ctx3.font= fontSize.toString() + 'px OmegleRegular';
    
    //ctx1.fillStyle = 'black'
    //ctx1.fillRect(drawX,drawY,100,100)
    
    posX = []
    posY = []
    posX.push(drawX)
    posY.push(drawY)
    for(var i = 0; i < 12; i++){
            
        for(var j = 0; j < i*6; j++){
        
        
            ret = offset(drawX, drawY, directions[Math.floor(j / i)], circleSize)
            drawX = ret[0]
            drawY = ret[1]
            posX.push(drawX)
            posY.push(drawY)
           
        }
        
        ret = offset(drawX, drawY, 6, circleSize)
        drawX = ret[0]
        drawY = ret[1]
    }
    
    //console.log(posX)
    //console.log(posY)

    //console.log(title.style.fontSize)


}

function hidewideScreenStuff(){

        wideScreen_instruct = document.getElementById("wideScreen_instruct")
        
        wideScreen_instruct.style.display = 'none'
        
        //console.log(wideScreen_instruct.style)

}

function formatTime(obj){
    var x=[];
    x.push(obj.m);
    x.push(obj.s);
    return x.join(':')
}

var bgcount = 9999990
var prevTime  = 0
var finalTime = -1

function secs2Time(secs) {
var minutes = Math.floor(secs / 60);
var seconds = Math.floor(secs % 60);
var obj = {
"m": minutes.toString().length === 1 ? '0' + minutes : minutes,
"s": seconds.toString().length === 1 ? '0' + seconds : seconds
};
return obj;
}

//üü™üü¶üü©üü®üüßüü•üü´‚¨ú
// ‚¨õüü®üü©


function get_square(value){
    if(value > 729){
        value = value / 729
    }
    var value_chars = {
        0:"‚¨õ",
        3:"üü¶",
        9:"üü©",
        27:"üü®",
        81:"üüß",
        243:"üü•",
        729:"üü™",
    }
    return value_chars[value]
}

function getColor_tup(value){

    if(value > 729){
        value = value / 729
    }
    var value_to_rgb = {
        0:[[92,92,92],[40,40,40]],
        3:[[82,159,237],[57,126,213]],
        9:[[140,184,74],[112,157,68]],
        27:[[250,227,67],[242,192,57]],
        81:[[239,157,46],[233,127,45]],
        243:[[222,72,58],[186,53,47]],
        729:[[159,75,182],[117,56,147]]
    }   

    return value_to_rgb[value]
}

function getColor(value){
    if(value == 1){value = 0}
    tuples = getColor_tup(value)

    c1 = tuples[0]
    c2 = tuples[1]

    c1s = "rgba(" + c1[0] + "," + c1[1] + "," + c1[2] + ", 1)"
    c2s = "rgba(" + c2[0] + "," + c2[1] + "," + c2[2] + ", 1)"

    return [c1s,c2s]
}

function getColorInv(value){
    //if(value == 1){value = 0}
    //tuples = getColor_tup(value)

    //c1_o = tuples[0] // original color before invert
    //c2_o = tuples[1]

    //c1 = [255 - c1_o[0], 255- c1_o[1], 255 - c1_o[2] ]  // perform invert
    //c2 = [255 - c2_o[0], 255- c2_o[1], 255 - c2_o[2] ]

    //c1s = "rgba(" + c1[0] + "," + c1[1] + "," + c1[2] + ", 1)" // color string
    //c2s = "rgba(" + c2[0] + "," + c2[1] + "," + c2[2] + ", 1)"

    return ["rgba(" + 40 + "," + 40 + "," + 40 + ", 1)"]
}


function text_board(){

    //var colG1  = [10,11,12]
    //var colG2  = [9,2,3,13]
    //var colG3 = [8,1,0,4,14]
    //var colG4  = [7,6,5,15]
    //var colG5  = [18,17,16]

    var today = new Date();
    var dd = String(today.getDate()).padStart(2, '0');
    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
    var yyyy = today.getFullYear();

    today = mm + '/' + dd + '/' + yyyy;

    var board_string = "729 - "+ today + "\n      "
    for (var i = colG1.length-1; i >= 0; i--){
        board_string += get_square(values[colG1[i]])
    }
    board_string += "      \n   "
    for (var i = colG2.length-1; i >= 0; i--){
        board_string += get_square(values[colG2[i]])
    }
    board_string += "   \n"
    for (var i = colG3.length-1; i >= 0; i--){
        board_string += get_square(values[colG3[i]])
    }
    board_string += "\n   "
    for (var i = colG4.length-1; i >= 0; i--){
        board_string += get_square(values[colG4[i]])
    }
    board_string += "   \n      "
    for (var i = colG5.length-1; i >= 0; i--){
        board_string += get_square(values[colG5[i]])
    }
    board_string += "      \n"

    //console.log(board_string)


    return board_string

}


var shift = 0
var shift2 = 0

function get_current_col_pos(index,col){

    for(var i = 1; i < col.length; i++){
        if (col[i] == index){
            return i
        }
    }
    return -1
}

function drawLoop(){

    //console.log("drawstuff"
    
    //drawBackground(Math.floor(Math.om() * 95))
    
    if(smoke){
        if(smokeFrame == 10){
            smokeFrame = 0
            smoke      = false
            ctx3.clearRect(0,0,canvas1.width,canvas1.height)
        } else {
            drawSmoke()
            smokeFrame += 1
            ctx3.globalAlpha =  1 - (smokeFrame / 10)
        }
    }

    if(displayTime && ! won){
        
        var currentTime = Math.round((new Date()).getTime() / 1000)
        if(currentTime != prevTime){
        
            var scoreDiv = document.getElementById("score");
            var runDate = Date.now() - startDate 
            //console.log(runDate)
            scoreDiv.innerText ="Time: " + formatTime(secs2Time((runDate)/1000))
            prevTime = currentTime
            finalTime = runDate
        }

    }
    
    if(update | first ){
    
        ctx1.clearRect(0,0,canvas1.width,canvas1.height)
        ctx1.fillStyle='black'
        ctx1.lineStyle='black'

        count = 0
        drawX = 0
        drawY = 0
        
        var updateScore = false
        
        if(step >= steps - 5){
        
            smoke = true
        
        }
        
        if(step >= steps){
            slide = false
            update = false      // after this we don't need to continue redrawing until we get another input
            updateScore = true  // but we do need to display the new score after we sum it below
            step  = 0
            values = nextValues.slice()

            next = actionQueue.shift()
            
            //console.log(pops)
            
            for(var i = 0; i < pops.length; i++){
                if(pops[i] == 1){
                    smoke = true
                }
            }
            
            //if(next){
            //    actionByKeyCode(next)
            //}
            
            actionQueue = [] // maybe just queueing 1 is better
            
        }
        
        var winBool = false
        
        //score = 0
        
        var zeros = 0
        for(var i = 0; i<values.length;i++){
        
            var value = values[i]
            if(value == 0){
                zeros += 1 // zeros++ doesn't seem right with no semicolon
            }
            if(value == 729 && won == false){
                winBool = true
            }
        }
        
        
        if(!displayTime && (updateScore || toggleScoreFlag)){

            var scoreDiv = document.getElementById("score");
            scoreDiv.innerText ="Score: " + score.toString()
           
           toggleScoreFlag = false
           
        }
        
        if(winBool){
            first  = false   // this won't ever matter in practice but helps development
            prompt = true
            update = false
            youWin()
        }
        
        var gameOverBool = false
        
        
        if(slide){
                //for(var i = 1; i < 19; i++){  //posX.length
                //    hexagon(posX[i], posY[i], ctx1, 0)// + "|" + i.toString()) //values[i])
                //}
                
                // var slideValue  = [] 
                // var slideStartX = []
                // var slideStartY = []
                // var deltaX = []
                // var deltaY = []
                //var steps = 200
                //var step  = 0
                
                for(var i = 0; i < slideValue.length; i++){
                
                    if(slideValue[i] != -1){
                
                        hexagon(slideStartX[i] + deltaX[i] * step,
                                slideStartY[i] + deltaY[i] * step,
                                ctx1,
                                slideValue[i])
                    }
                }
                
                step = step + 1
        } else {
            update = false
            for(var i = 0; i < 19; i++){  //posX.length
                if(values[i] != 0){
                    hexagon(posX[i], posY[i], ctx1, values[i])// + "|" + i.toString()) //values[i])
                    // colR1, colR2, colR3, colR4, colR5, colG1, colG2, colG3, colG4, colG5, colB1, colB2, colB3, colB4, colB5

                    //R  1,4   var e_z_cols 
                    //G  5,2   var a_d_cols 
                    //B  0,3   var w_x_cols
                    
                    if(direction_select == 1){
                        //R  1,4   var e_z_cols
                        ret = e_z_cols[i]
                        col = ret[0]
                        possible = possible_slides_r[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp > possible[1]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                    if(direction_select == 4){
                        //R  1,4   var e_z_cols
                        ret = e_z_cols[i]
                        col = ret[0]
                        possible = possible_slides_r[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp < possible[2]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                    if(direction_select == 5){
                        //G  5,2   var a_d_cols 
                        ret = a_d_cols[i]
                        col = ret[0]
                        possible = possible_slides_g[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp < possible[2]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                    if(direction_select == 2){
                        //G  5,2   var a_d_cols 
                        ret = a_d_cols[i]
                        col = ret[0]
                        possible = possible_slides_g[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp > possible[1]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                    // case 0 [9, 2, 3, 13] ( this isn't right )  (direction W)
                    if(direction_select == 0){
                        //B  0,3   var w_x_cols
                        ret = w_x_cols[i]
                        col = ret[0]
                        possible = possible_slides_b[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp < possible[2]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                    if(direction_select == 3){
                        //B  0,3   var w_x_cols
                        ret = w_x_cols[i]
                        col = ret[0]
                        possible = possible_slides_b[ret[1]]
                        ccp = get_current_col_pos(i, col)
                        if(ccp > possible[1]){
                            draw_arrow(posX[i], posY[i], direction_select, ctx1)
                        }
                    }
                }
            }
        }
    
    }else{ // no update
        if(checkGameOver()){
        
        first  = false   // this won't ever matter in practice but helps development
        prompt = true
        update = false
        gameOver()
    }
    }

    window.requestAnimationFrame(drawLoop)
    
}

var smokeList = []
var numSmokes = 20 // particles per pop

function Particle( x, y, radius, color, scale ) {
     this.init( x, y, radius, color, scale );
     //console.log(this)
}

Particle.prototype = {
    init: function( x, y, radius, color, scale ) {
        this.alive = true;
        this.radius = radius || 10;
        this.wander = 1.15;
        this.theta = Math.random() * Math.PI * 2;
        this.drag = 0.92;
        this.color = color
        this.x = x || 0.0;
        this.y = y || 0.0;
        this.vx = 0.0;
        this.vy = 0.0;
        this.scale = scale;
    },
    move: function() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.drag;
        this.vy *= this.drag;
        this.theta += (Math.random()-.5) * this.wander;
        this.vx += Math.sin( this.theta ) * 0.3;
        this.vy += Math.cos( this.theta ) * 0.3 - .02;
        this.radius *= this.scale;
        this.alive = this.radius > 0.5;
    },
    draw: function( ctx ) {
    
        //console.log('drawing particle ' + this.x + "  " + this.y)
        ctx.beginPath();
        ctx.arc( this.x, this.y, this.radius, 0, Math.PI * 2 );
        ctx.fillStyle = this.color;
        ctx.fill();
    }
};

var parity = 0
var backgroundNum = 18
var bgStarts  = []  // we data oriented
var bgVectors = []
var bgSteps   = []
var bgColors  = []


var pastels = ['#ffb3ba', '#ffdfba', '#ffffff', '#ffffba', '#baffc9', '#bae1ff', '#ffffff']
var pastels2 =  ['#b3b3b3', '#dfdfdf', '#ffffff', '#c9c9c9', '#8a8a8a']

//console.log({deltaCount:0,end: Math.floor(Math.random() * 3000)})
//console.log(Math.floor(Math.random() * 3000))
//console.log((Math.random() * 3000))

var toggleScoreFlag = false

function toggleScore(){

    //console.log(displayTime)

    displayTime = ! displayTime
    toggleScoreFlag = true
}

function drawBackground(shape){

    //ctx4.clearRect(0,0,width,height)
    ctx4.globalCompositeOperation="xor"
    ctx4.fillStyle = 'white'
    ctx4.globalAlpha = .01
    ctx4.fillRect(0,0,width,height)
    //"xor";
    
    var maxVal = Math.max(...values)
    
    //console.log(maxVal)
    
    ctx4.globalAlpha = Math.min(maxVal / 1000, .34) 
    
    //console.log(ctx4.globalAlpha)
    
    if(bgStarts.length == 0){
    
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        
        //console.log(bgSteps)
        
        bgSteps[0].deltaCount = Math.floor(Math.random() * bgSteps[0].end)  // so they don't all start at the top
        bgSteps[1].deltaCount = Math.floor(Math.random() * bgSteps[1].end)
        bgSteps[2].deltaCount = Math.floor(Math.random() * bgSteps[2].end)
        bgSteps[3].deltaCount = Math.floor(Math.random() * bgSteps[3].end)
        bgSteps[4].deltaCount = Math.floor(Math.random() * bgSteps[4].end)
        bgSteps[5].deltaCount = Math.floor(Math.random() * bgSteps[5].end)
        bgSteps[6].deltaCount = Math.floor(Math.random() * bgSteps[6].end)
        bgSteps[7].deltaCount = Math.floor(Math.random() * bgSteps[7].end)
        bgSteps[8].deltaCount = Math.floor(Math.random() * bgSteps[8].end)
        bgSteps[9].deltaCount = Math.floor(Math.random() * bgSteps[9].end)
        bgSteps[10].deltaCount = Math.floor(Math.random() * bgSteps[10].end)
    
        bgVectors.push(fiveVecs(bgStarts[0],fiveBelow(), bgSteps[0].end))
        bgVectors.push(fiveVecs(bgStarts[1],fiveBelow(), bgSteps[1].end))
        bgVectors.push(fiveVecs(bgStarts[2],fiveBelow(), bgSteps[2].end))
        bgVectors.push(fiveVecs(bgStarts[3],fiveBelow(), bgSteps[3].end))
        bgVectors.push(fiveVecs(bgStarts[4],fiveBelow(), bgSteps[4].end))
        bgVectors.push(fiveVecs(bgStarts[5],fiveBelow(), bgSteps[5].end))
        bgVectors.push(fiveVecs(bgStarts[6],fiveBelow(), bgSteps[6].end))
        bgVectors.push(fiveVecs(bgStarts[7],fiveBelow(), bgSteps[7].end))
        bgVectors.push(fiveVecs(bgStarts[8],fiveBelow(), bgSteps[8].end))
        bgVectors.push(fiveVecs(bgStarts[9],fiveBelow(), bgSteps[9].end))
        bgVectors.push(fiveVecs(bgStarts[10],fiveBelow(), bgSteps[10].end))
        
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
    
    }
    
    //console.log(bgSteps) 
    
    for(var i = 0; i < bgStarts.length; i++){

    
        if(bgSteps[i].deltaCount == bgSteps[i].end){ // if it's reached the target make a new one
            
            bgStarts[i]  = fiveAbove()
            bgSteps[i]   = {deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)}
            bgVectors[i] = fiveVecs(bgStarts[i],fiveBelow(), bgSteps[i].end)
            bgColors[i]  = pastels[Math.floor(Math.random()*5)]
        
        }
        
        if(shape == i){
    
            currentPos = [  {x:bgStarts[i][0].x + bgVectors[i][0].x * bgSteps[i].deltaCount, y:bgStarts[i][0].y + bgVectors[i][0].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][1].x + bgVectors[i][1].x * bgSteps[i].deltaCount, y:bgStarts[i][1].y + bgVectors[i][1].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][2].x + bgVectors[i][2].x * bgSteps[i].deltaCount, y:bgStarts[i][2].y + bgVectors[i][2].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][3].x + bgVectors[i][3].x * bgSteps[i].deltaCount, y:bgStarts[i][3].y + bgVectors[i][3].y * bgSteps[i].deltaCount} ] 
                            
                            /*,
                            {x:bgStarts[i][4].x + bgVectors[i][4].x * bgSteps[i].deltaCount, y:bgStarts[i][4].y + bgVectors[i][4].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][5].x + bgVectors[i][5].x * bgSteps[i].deltaCount, y:bgStarts[i][5].y + bgVectors[i][5].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][6].x + bgVectors[i][6].x * bgSteps[i].deltaCount, y:bgStarts[i][6].y + bgVectors[i][6].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][7].x + bgVectors[i][7].x * bgSteps[i].deltaCount, y:bgStarts[i][7].y + bgVectors[i][7].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][8].x + bgVectors[i][8].x * bgSteps[i].deltaCount, y:bgStarts[i][8].y + bgVectors[i][8].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][9].x + bgVectors[i][9].x * bgSteps[i].deltaCount, y:bgStarts[i][9].y + bgVectors[i][9].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][10].x + bgVectors[i][10].x * bgSteps[i].deltaCount, y:bgStarts[i][10].y + bgVectors[i][10].y * bgSteps[i].deltaCount} ] */
        
            ctx4.beginPath()
            
            roundedPoly(ctx1, currentPos, circleSize/20)
            
            ctx4.fillStyle = bgColors[i]
            ctx4.fill()
        
        }
        
        bgSteps[i].deltaCount += 1

    }    
    
}

function fiveAbove(){
    return [{x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height} ]
            
            /*,
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height}]*/

}

function fiveBelow(){
    return [{x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height} ] 
            
            /*,
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height}]*/
}
function fiveVecs(start, target, steps){

    return [{x: (target[0].x - start[0].x)/steps, y: (target[0].y - start[0].y)/steps},
            {x: (target[1].x - start[1].x)/steps, y: (target[1].y - start[1].y)/steps},
            {x: (target[2].x - start[2].x)/steps, y: (target[2].y - start[2].y)/steps},
            {x: (target[3].x - start[3].x)/steps, y: (target[3].y - start[3].y)/steps} ] 
            
            /*,
            {x: (target[4].x - start[4].x)/steps, y: (target[4].y - start[4].y)/steps},
            {x: (target[5].x - start[5].x)/steps, y: (target[5].y - start[5].y)/steps},
            {x: (target[6].x - start[6].x)/steps, y: (target[6].y - start[6].y)/steps},
            {x: (target[7].x - start[7].x)/steps, y: (target[7].y - start[7].y)/steps},
            {x: (target[8].x - start[8].x)/steps, y: (target[8].y - start[8].y)/steps},
            {x: (target[9].x - start[9].x)/steps, y: (target[9].y - start[9].y)/steps},
            {x: (target[10].x - start[10].x)/steps, y: (target[10].y - start[10].y)/steps}] */

}

function drawSmoke(){

    ctx3.clearRect(0,0,canvas1.width,canvas1.height)

    if(smokeFrame == 0){
    
        
        smokeList = []
    
        for(var i = 0; i < pops.length; i++){
            if(pops[i] == 1){
                particleList = []
                
                var color = getColor(values[i])[0]
                var color2 = getColor(values[i]/3)[0]
                for(var j = 0; j < 40; j++){
                
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize),
                                                    posY[i] +((Math.random() -.5) *circleSize),
                                                    Math.random()* height/60, 
                                                    color, 1.03))       
                                                    
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize),
                                                    posY[i] +((Math.random() -.5) *circleSize),
                                                    Math.random()* height/60, 
                                                    '#fff', 1.03))
                                                                                 
                }
                for(var j = 0; j < 6; j++){
                
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize * 1.3),
                                                    posY[i] +((Math.random() -.5) *circleSize * 1.3) ,
                                                    Math.random()* 30, 
                                                    '#fa0', .94))
                }
                
                smokeList.push(particleList.slice())
            }
        }
    }
    
    //console.log(smokeList)
    
    for(var i = 0; i < smokeList.length; i++){
        //console.log(i)
        for(var j = 0; j < smokeList[i].length; j++){
        
            //console.log(smokeList[i][j])
        
            smokeList[i][j].move()
            //smokeList[i][j].move()
            //smokeList[i][j].move()
            //smokeList[i][j].move()
            smokeList[i][j].draw(ctx3)
        }
    }


}

// colR1, colR2, colR3, colR4, colR5, colG1, colG2, colG3, colG4, colG5, colB1, colB2, colB3, colB4, colB5
// R is E-Z direction, smaller values E, larger values Z
// G is A-D direction, smaller values D, larger values A
// B is W-X direction, smaller values X, larger values W

var possible_slides_r = []
var possible_slides_g = []
var possible_slides_b = []

function checkGameOver(){
    
    var slide = 0
    possible_slides_r = []
    possible_slides_g = []
    possible_slides_b = []

    ret = checkCol(colR1)
    slide += ret[0]
    possible_slides_r.push(ret)
    ret = checkCol(colR2)
    slide += ret[0]
    possible_slides_r.push(ret)
    ret = checkCol(colR3)
    slide += ret[0]
    possible_slides_r.push(ret)
    ret = checkCol(colR4)
    slide += ret[0]
    possible_slides_r.push(ret)
    ret = checkCol(colR5)
    slide += ret[0]
    possible_slides_r.push(ret)

    ret = checkCol(colG1)
    slide += ret[0]
    possible_slides_g.push(ret)
    ret = checkCol(colG2)
    slide += ret[0]
    possible_slides_g.push(ret)
    ret = checkCol(colG3)
    slide += ret[0]
    possible_slides_g.push(ret)
    ret = checkCol(colG4)
    slide += ret[0]
    possible_slides_g.push(ret)
    ret = checkCol(colG5)
    slide += ret[0]
    possible_slides_g.push(ret)

    ret = checkCol(colB1)
    slide += ret[0]
    possible_slides_b.push(ret)
    ret = checkCol(colB2)
    slide += ret[0]
    possible_slides_b.push(ret)
    ret = checkCol(colB3)
    slide += ret[0]
    possible_slides_b.push(ret)
    ret = checkCol(colB4)
    slide += ret[0]
    possible_slides_b.push(ret)
    ret = checkCol(colB5)
    slide += ret[0]
    possible_slides_b.push(ret)
    
    //console.log("slide from checklose:" + slide.toString())
    
    //console.log(slide)

    if(slide){
        return false
    } else {
        return true
    }
}

async function youWin(){

    won = true
    timeToWin = Math.floor((Date.now() - startDate) / 1000);  // seconds to reach 729

    var winDiv = document.getElementById("youWin");
    var innerDiv = document.getElementById("inner2");
    innerDiv.innerText = "You Won!"

    // Only submit once
    if (!timeSubmitted) {
        timeSubmitted = true;
        // Always auto-submit (works for both logged-in and anonymous users)
        await autoSubmitTime(timeToWin);
    }

    winDiv.style.display = 'inline-block'

}

function continueGame(){

    var winDiv = document.getElementById("youWin");
    winDiv.style.display = 'none'
    prompt = false

}

async function gameOver(){

    var overDiv = document.getElementById("gameOver");
    var innerDiv = document.getElementById("inner1");
    innerDiv.innerText ="Game over! Your score is "+ score.toString() + "."
    overDiv.style.display = 'inline-block'

    // Only submit once
    if (!highScoreSubmitted) {
        highScoreSubmitted = true;
        // Always auto-submit (works for both logged-in and anonymous users)
        await autoSubmitHighScore(score);
    }

}

function toClipboard(print_score){

    var text;

    // If we have a submitted score ID, just share the replay link
    // Otherwise share the full board display
    console.log('toClipboard: lastSubmittedScoreId =', lastSubmittedScoreId);
    if (lastSubmittedScoreId) {
        text = `https://nathan-sixnines.github.io/729/leaderboard.html?replay=${lastSubmittedScoreId}`;
    } else {
        text = text_board();

        if(print_score){
            text +=  "Score: " + score + "\n"
        } else {
            var runDate = Date.now() - startDate
            text += "Time: " + formatTime(secs2Time((runDate)/1000)) + "\n"
        }

        text += "https://nathan-sixnines.github.io/729";
    }

    navigator.clipboard.writeText(text)
    setTimeout(function() { alert('Copied to clipboard'); }, 1);
}

// Save game state to localStorage
function saveGameState(){
    try {
        // Check if we're in a game over or win state
        var gameOverDiv = document.getElementById("gameOver");
        var youWinDiv = document.getElementById("youWin");
        var showGameOver = gameOverDiv && gameOverDiv.style.display === 'inline-block';
        var showYouWin = youWinDiv && youWinDiv.style.display === 'inline-block';

        var gameState = {
            values: values,
            nextValues: nextValues,
            time: time,
            gameRecord: gameRecord,
            score: score,
            startDate: startDate,
            won: won,
            showGameOver: showGameOver,
            showYouWin: showYouWin,
            lastSubmittedScoreId: lastSubmittedScoreId,
            rngState: {
                seed: rngState.seed,
                current: rngState.current
            }
        };
        localStorage.setItem('729_gameState', JSON.stringify(gameState));
        console.log('Saved game state with lastSubmittedScoreId:', lastSubmittedScoreId);
    } catch(e) {
        console.log('Error saving game state:', e);
    }
}

// Restore game state from localStorage
function restoreGameState(){
    try {
        var savedState = localStorage.getItem('729_gameState');
        if(savedState){
            var gameState = JSON.parse(savedState);

            // Restore board state
            values = gameState.values || new Array(19).fill(0);
            nextValues = gameState.nextValues || new Array(19).fill(0);

            // Restore game metadata
            time = gameState.time;
            gameRecord = gameState.gameRecord || {'time': time, 'moves': []};
            score = gameState.score || 0;
            startDate = gameState.startDate || Date.now();
            won = gameState.won || false;
            lastSubmittedScoreId = gameState.lastSubmittedScoreId || null;
            console.log('Restored lastSubmittedScoreId:', lastSubmittedScoreId);

            // Restore RNG state exactly as it was
            if(gameState.rngState){
                rngState.seed = gameState.rngState.seed;
                rngState.current = gameState.rngState.current;
            } else {
                // Fallback for old saves without RNG state
                initRNG(time);
            }

            // Update score display
            var scoreDiv = document.getElementById("score");
            if(scoreDiv){
                scoreDiv.innerText = "Score: " + score.toString();
            }

            // Restore modal state if needed
            if(gameState.showGameOver){
                var gameOverDiv = document.getElementById("gameOver");
                var innerDiv = document.getElementById("inner1");
                if(gameOverDiv && innerDiv){
                    innerDiv.innerText = "Game over! Your score is " + score.toString() + ".";
                    gameOverDiv.style.display = 'inline-block';
                    prompt = true;

                    // Update modal buttons based on current auth state
                    // updateAuthUI handles game over login button visibility
                    updateAuthUI();
                }
            }
            if(gameState.showYouWin){
                var youWinDiv = document.getElementById("youWin");
                var innerDiv2 = document.getElementById("inner2");
                if(youWinDiv && innerDiv2){
                    innerDiv2.innerText = "You Won!";
                    youWinDiv.style.display = 'inline-block';
                    prompt = true;

                    // Update modal buttons based on current auth state
                    updateWinModalButtons();
                }
            }

            // Trigger a redraw
            update = true;

            console.log('Game state restored with RNG state');
            return true;
        }
    } catch(e) {
        console.log('Error restoring game state:', e);
    }
    return false;
}

// Clear saved game state
function clearSavedGameState(){
    try {
        localStorage.removeItem('729_gameState');
    } catch(e) {
        console.log('Error clearing game state:', e);
    }
}

function newGame(){

    games += 1

    // Clear any saved game state when starting new game
    clearSavedGameState();

    nextValues.fill(0)

    score = 0
    startDate  = Date.now()

    // Reset game record for validation
    time = Math.round((new Date()).getTime() / 1000);
    initRNG(time);
    gameRecord = {'time': time, 'moves': []};

    // Reset submission flags
    timeToWin = null;
    timeSubmitted = false;
    highScoreSubmitted = false;
    lastSubmittedScoreId = null;

    ctx4.clearRect(0,0,width,height)

    addRandom()
    addRandom()

    values = nextValues.slice()

    prompt = false
    update = true

    var overDiv = document.getElementById("gameOver");
    overDiv.style.display = 'none'

}

// jsperf.com javascript performance website

function checkCol(col){

    var check = -1
    var count = 0
    
    var maxCount = 0

    var slide = false
    // [slide, first_gap, last_gap]
    var min = 999
    var max = -999
    var pos = null
    var first_zero = null
    debug = false


    s = ""
    for(var i =0; i < col.length; i++){
        s += " " +  values[col[i]]
    }
    //console.log(s)

    if(values[col[0]] != 0){
        //console.log(values[col[0]])
        debug = true
    }

    for(var i = 0; i < col.length; i++){
        var val = values[col[i]]
        if(val == 0){
            slide = true
            if(i < min){min = i}
            if(i > max){max = i}
        }
        else if(val == check){
            count += 1
        } else {
            count = 1
            check = val
            pos = i
        }
        
        if(count > maxCount){
            maxCount = count
        }
        
        if(count >= 3){
            slide = true
            //console.log("row")
            //console.log(pos)
            //console.log(i)
            if(pos < min){min = pos}
            if(i > max){max = i}
        }
    }
    //ret = [slide, Math.min(gaps[0],slides[0]),Math.max(gaps[gaps.length-1],slides[slides.length-1])]
    ret = [slide, min,max]
    if(debug){
        //console.log(ret)
    }
    return ret
}

function slideCol(col, up){

    //console.log('slide col')

    var slide = false   // this one we return an allows us to keep track if anything slid at all

    var runValue = 0
    var run      = 0
    
    if(! up){
        col = col.slice().reverse()  // don't want to reverse original list
    }
    
    var outCol        = []
    var slideStarts   = []
    var targetMarker  = 0   // index of where slides target
   
    //console.log("col")
    //console.log(col)
    
    var zeroGap = false
    
    for(var i = 0; i < col.length; i++){
    
        //console.log(outCol)
    
        var value = values[col[i]]
        
        //console.log("value:    " + value.toString())
        //console.log("runValue: " + runValue.toString())
        //console.log("run:      " + run.toString())
        
        if(value == 0){
            zeroGap = true
        } else {
        
            if(zeroGap){
                slide = true
            }
        
            if(value == runValue){
                run = run + 1
                if(run == 2){
                    slides[col[i]] = col[targetMarker]
                    slideStarts.push(col[i])
                    targetMarker = targetMarker + 1
                    outCol.push(value)
                }
                
                else if(run == 3){
                    slide = true
                
                    runValue = 0
                    run      = 0
                    outCol.pop(value)
                    outCol.pop(value)
                    outCol.push(value * 3)
                    score += value * 3
                    targetMarker = targetMarker - 2
                  
                    slides[col[i]]    = col[targetMarker]
                    slides[slideStarts[0]] = col[targetMarker]
                    //slides[slideStarts[1]] = col[targetMarker]
                    pops[col[targetMarker]] = 1
                    
                    targetMarker = targetMarker + 1
                    slideStarts = []                  
                }
            }
            
            else{
            
                slideStarts = []
                slides[col[i]] = col[targetMarker]
                targetMarker = targetMarker + 1
                outCol.push(value)
                
                runValue   = value
                run        = 1

            }
        }
    }
    
    for(var i = 0; i < col.length; i++){
    
        if(i < outCol.length){
            nextValues[col[i]] = outCol[i]
        }   else {
            nextValues[col[i]] = 0
        }
        
    }
    
    if(slide){
        return 1
    }
    else {
        return 0
    }
}

function addRandom(){

    //console.log('adding random')
    var pickList = []

    for(var i = 0; i < values.length; i++){
        if(nextValues[i] == 0){
            pickList.push(i)
        }
    }

    var pick = pickList[Math.floor(rand()*pickList.length)];

    // IMPORTANT: Must use seeded rand() here for validation to work!
    if(rand() > 5/9){
        //if(mod(games,2)== 0){
            nextValues[pick] = 9
        //} else {
        //    nextValues[pick] = 3
        //}
    } else {
            nextValues[pick] = 3
    }
    //nextValues[0] = 3
  
}

function slideR(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        pops   = new Array(19).fill(0)

        var a  = slideCol(colR1,up)
        var b  = slideCol(colR2,up)
        var c  = slideCol(colR3,up)
        var d  = slideCol(colR4,up)
        var e  = slideCol(colR5,up)

        if(a+b+c+d+e > 0){
            // Move actually executed, record it
            // R true = direction 1 (up to the right)
            // R false = direction 4 (down to the left)
            gameRecord.moves.push(up ? 1 : 4);
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}
function slideG(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index(old values) to target position index
        pops   = new Array(19).fill(0)

        var a  = slideCol(colG1,up)
        var b  = slideCol(colG2,up)
        var c  = slideCol(colG3,up)
        var d  = slideCol(colG4,up)
        var e  = slideCol(colG5,up)

        var sum = a+b+c+d+e
        if(sum > 0){
            // Move actually executed, record it
            // G true = direction 2 (right)
            // G false = direction 5 (left)
            gameRecord.moves.push(up ? 2 : 5);
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}
function slideB(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        pops   = new Array(19).fill(0)

        var a  = slideCol(colB1,up)
        var b  = slideCol(colB2,up)
        var c  = slideCol(colB3,up)
        var d  = slideCol(colB4,up)
        var e  = slideCol(colB5,up)
        if(a+b+c+d+e > 0){
            // Move actually executed, record it
            // B false = direction 0 (up to the left)
            // B true = direction 3 (down to the right)
            gameRecord.moves.push(up ? 3 : 0);
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}



// I don't think this is right anymore but might be useful forensics:
// direction codes :
// up right   = 0   
// up left    = 1
// left       = 2
// down left  = 3
// down right = 4
// right      = 5


function animate(){

    slideValue  = []
    slide       = false
    
    slideStartX = []
    slideStartY = []
    
    deltaX = []
    deltaY = []

    for (var i = 0; i < slides.length; i++){
        if(slides[i] != -1){
              
            slideStartX.push(posX[i])
            slideStartY.push(posY[i])
            
            diffX = (posX[slides[i]] - posX[i]) / steps   // subtract original location from target
            diffY = (posY[slides[i]] - posY[i]) / steps   // because we want to end up at target by adding it back 
            
            deltaX.push(diffX)
            deltaY.push(diffY)
            
            slideValue.push(values[i])
            
        }
    }
    
    slide = true

}


// w = 87
// e = 69
// d = 68
// x = 88
// z = 90
// a = 65

document.onkeydown = function(e) {
    if(! update){
        actionByKeyCode(e.keyCode)
    }
    else{
        actionQueue.push(e.keyCode)
    }
}

function actionByKeyCode(code){
    // Map keyboard to direction numbers (0-5)
    // This way we use the same slideSelect() that mouse/touch uses
    switch (code) {
        case 87: // w -> direction 0 (B false = up to the left)
            slideSelect(0)
            break
        case 69: // e -> direction 1 (R true = up to the right)
            slideSelect(1)
            break
        case 68: // d -> direction 2 (G true = right)
            slideSelect(2)
            break
        case 88: // x -> direction 3 (B true = down to the right)
            slideSelect(3)
            break
        case 90: // z -> direction 4 (R false = down to the left)
            slideSelect(4)
            break
        case 65: // a -> direction 5 (G false = left)
            slideSelect(5)
            break
    }
}

document.getElementById("container").addEventListener('mousedown', handleClickDown, false)
document.getElementById("container").addEventListener('mouseup', handleClickUp, false)
document.getElementById("container").addEventListener('mousemove', mouseMove, false)


var click = false
var xDownClick = null;                                                        
var yDownClick = null;
var critical = false

//direction_select = -1
//arrow_hint_intensity = 0



function handle_input(startX, startY, newX, newY){

    var distance = Math.sqrt(Math.pow(newX - startX,2) + Math.pow(newY - startY,2))

    var unit = height / 500

    //console.log(distance)

    var xDiff =  newX - startX
    var yDiff =  newY - startY 

    var rad = (Math.atan2(yDiff, xDiff) / Math.PI) + 1;
    bin_rad_ret = bin_rad(rad)

    if( distance < unit * 12){

        arrow_hint_intensity_2 = 0   
        direction_select = bin_rad_ret[0]
        arrow_hint_intensity = bin_rad_ret[1]
        update = true
        critical = false

    }
    if(distance >= unit * 12 && distance < (unit * 16)){



        arrow_hint_intensity_2 = 0   
        direction_select = bin_rad_ret[0]
        if(bin_rad_ret[1] < .5){
            arrow_hint_intensity = bin_rad_ret[1] *2
        }else{
            arrow_hint_intensity = 1
        }
        update = true
        critical = false


        //direction_select = bin_rad_ret[0]
        //arrow_hint_intensity = bin_rad_ret[1]
        //arrow_hint_intensity = bin_rad_ret[1]
        //arrow_hint_intensity_2 = (distance - unit * 4) / (unit * 8)

        //update = true
        //critical = false

        //console.log("move case 2")

    }
    // don't set critical if not clearly in direction?
    else if(distance >= (unit * 16)){


        arrow_hint_intensity_2 = 0   
        direction_select = bin_rad_ret[0]

        update = true
        //console.log(bin_rad_ret)
        if(bin_rad_ret[1] < .25){
            critical = false
            arrow_hint_intensity = bin_rad_ret[1] * 4
        }else if(bin_rad_ret[1] > .25){
            critical = true
            arrow_hint_intensity = 1
            arrow_hint_intensity_2 = 1
        }

        //arrow_hint_intensity = bin_rad_ret[1]
        //direction_select = bin_rad_ret[0]
        //arrow_hint_intensity_2 = 1
        //critical = true
        //update = true
    }

}



document.addEventListener('touchstart', handleTouchStart, false);        
document.addEventListener('touchend', handleTouchEnd)
document.addEventListener('touchmove', function(evt) {
    // I hate safari
    //var userAgent = window.navigator.userAgent;
    //var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))
    //if (isSafari){
    //    evt.preventDefault();
    //}
    handleTouchMove(evt)
})



document.addEventListener("resize", initCanvas);

function handleClickUp(evt){
    handle_end()
}

function handleTouchEnd(evt){
    handle_end()
}

function handle_end(){
    if(critical){
        slideSelect(direction_select)
    }
    click = false
    xDownClick = null
    yDownClick = null
    direction_select = -1
    update = true
}

function handleTouchMove(evt) {

    if(click){

        var newX = evt.touches[0].clientX;                                    
        var newY = evt.touches[0].clientY;

        handle_input(xDownClick, yDownClick,newX,newY)
        
        // reset values 
        //xDown = null;
        //yDown = null;    
    }                                         
}

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches  // jQuery
}                                                     

function handleTouchStart(evt) {                                         
    xDownClick = getTouches(evt)[0].clientX                               
    yDownClick = getTouches(evt)[0].clientY
    click = true                                    
}

function handleClickDown(evt){

xDownClick = evt.pageX - canvas1.offsetLeft;
yDownClick = evt.pageY - canvas1.offsetTop;
click = true

//ctx1.beginPath();
//ctx1.arc(xDownClick, yDownClick, 15, 0, 2 * Math.PI);
//ctx1.stroke();

}


function mouseMove(evt){
    if(click){
        x2 = evt.pageX - canvas1.offsetLeft
        y2 = evt.pageY - canvas1.offsetTop
        handle_input(xDownClick, yDownClick,x2,y2)

    }
}


function sector_alignment(a,b){
    c = Math.abs(a-b)
    d = 1/6 - c
    d = d * 6
    return d
}

// bin radian value
function bin_rad(rad){

    //console.log(rad)

    //R  1,4   var e_z_cols 
    //G  5,2   var a_d_cols 
    //B  0,3   var w_x_cols


    if(rad < 1/6){
        rad += 2 // avoid modular discontiunity
    }
    // rad 2/6
    if(rad >= (1/6) && rad < (3/6)){
        //console.log('w , rad > 1/6 && rad <= 3/6, rad: ' + rad.toString())
        return [0, sector_alignment(2/6,rad)]
    }
    // rad 4/6
    else if(rad >= (3/6) && rad < (5/6)){
        //console.log('e , rad > 1/2 && rad <= 5/6, rad: ' + rad.toString())
        return [1, sector_alignment(4/6,rad)]
    }
    // rad 6/6
    else if(rad >= (5/6) && rad < (7/6)){
        //console.log('d , rad > 5/6 && rad <= 7/6, rad: ' + rad.toString())
        return [2, sector_alignment(6/6,rad)]
    }
    // rad 8/6
    else if(rad >= (7/6) && rad < (9/6)){
        //console.log('x , rad > 7/6 && rad <= 9/6, rad: ' + rad.toString())
        return [3, sector_alignment(8/6,rad)]
    }
    // rad 10/6
    else if(rad >= (9/6) && rad < (11/6)){
        //console.log('z , rad > 9/6 && rad <= 11/6, rad: ' + rad.toString())
        return [4, sector_alignment(10/6,rad)]
    }
    // rad 12/6
    else{
        //console.log('a , other rad,                rad: ' + rad.toString())
        return [5, sector_alignment(12/6,rad)]
    }
}

function slideSelect(direction){
    // Slide functions record moves internally when they execute

    switch(direction){
        case 0:  // up to the left
            slideB(false)
            break
        case 1:   // up to the right
            slideR(true)
            break
        case 2:  // right
            slideG(true)
            break
        case 3:  // down to the right
            slideB(true)
            break
        case 4:   // down to the left
           slideR(false)
            break
        case 5:  // left
            slideG(false)
            break
    }
}

//console.log(canvas1)

initCanvas()



for(var i = 0; i < 19; i++){  //posX.length
   
    hexagon(posX[i], posY[i], ctx2, values[i])// + "|" + i.toString()) //values[i])
   
}

//drawBackground()

// Try to restore saved game state, or initialize new game
if(!restoreGameState()){
    // No saved state, start fresh
    addRandom()
    addRandom()
}

//nextValues[0] = 1
//nextValues[1] = 2
//nextValues[4] = 3
//nextValues[8] = 4

// ===== AUTHENTICATION CODE =====
var currentUser = null;
var API_URL = 'https://chcdtf38fi.execute-api.us-east-1.amazonaws.com';  // Backend API
var timeToWin = null;  // Track time to reach 729 tile
var timeSubmitted = false;  // Track if time was already submitted
var highScoreSubmitted = false;  // Track if high score was already submitted
var sessionId = null;  // Persistent session ID for anonymous submissions
var lastSubmittedScoreId = null;  // Store the ID of the last submitted score for sharing

// Generate a simple UUID
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Get or create session ID
function getSessionId() {
    if (sessionId) return sessionId;

    sessionId = localStorage.getItem('gameSessionId');
    if (!sessionId) {
        sessionId = generateUUID();
        localStorage.setItem('gameSessionId', sessionId);
    }
    return sessionId;
}


async function claimAnonymousScores() {
    var sid = getSessionId();

    try {
        var response = await fetch(API_URL + '/claim-scores', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ session_id: sid })
        });

        if (response.ok) {
            var data = await response.json();
            console.log(`Claimed ${data.claimed_count} anonymous scores`);
            if (data.claimed_count > 0) {
                // Show success message
                alert(`‚úì ${data.claimed_count} score(s) claimed and added to your leaderboard!`);
            }
            return data.claimed_count;
        }
    } catch (error) {
        console.error('Error claiming anonymous scores:', error);
    }
    return 0;
}

async function checkAuth() {
    try {
        var response = await fetch(API_URL + '/me', {
            credentials: 'include'
        });

        if (response.ok) {
            currentUser = await response.json();
            updateAuthUI();

            // Claim any anonymous submissions from this session
            await claimAnonymousScores();

            return currentUser;
        } else {
            // Not logged in with Discord, check for local display name
            var displayName = localStorage.getItem('displayName');
            if (displayName) {
                currentUser = {
                    username: displayName,
                    isLocalUser: true
                };
                updateAuthUI();
                return currentUser;
            } else {
                currentUser = null;
                updateAuthUI();
                return null;
            }
        }
    } catch (error) {
        console.error('Auth check failed:', error);

        // Fallback: check for local display name
        var displayName = localStorage.getItem('displayName');
        if (displayName) {
            currentUser = {
                username: displayName,
                isLocalUser: true
            };
            updateAuthUI();
            return currentUser;
        }

        currentUser = null;
        updateAuthUI();
        return null;
    }
}

function updateAuthUI() {
    var loginBtn = document.getElementById('loginBtn');
    var userInfo = document.getElementById('userInfo');
    var usernameSpan = document.getElementById('username');
    var gameOverLoginBtn = document.getElementById('gameOverLoginBtn');
    var gameOverLoginPrompt = document.getElementById('gameOverLoginPrompt');

    if (currentUser) {
        // User is logged in
        loginBtn.style.display = 'none';
        userInfo.style.display = 'block';
        usernameSpan.textContent = currentUser.username;
        gameOverLoginBtn.style.display = 'none';
        gameOverLoginPrompt.style.display = 'none';
    } else {
        // User is not logged in
        loginBtn.style.display = 'block';
        userInfo.style.display = 'none';
        gameOverLoginBtn.style.display = 'inline-block';
        gameOverLoginPrompt.style.display = 'block';
    }
}

function loginWithDiscord() {
    const authUrl = API_URL + '/auth/discord';

    // Open OAuth in popup window
    const width = 600;
    const height = 700;
    const left = window.screen.width / 2 - width / 2;
    const top = window.screen.height / 2 - height / 2;

    const popup = window.open(
        authUrl,
        'discordLogin',
        `width=${width},height=${height},left=${left},top=${top},toolbar=no,location=no,menubar=no`
    );

    // Handle popup blocked
    if (!popup || popup.closed || typeof popup.closed === 'undefined') {
        // Fallback to full page redirect if popup was blocked
        alert('Popup was blocked. Redirecting to login page...');
        window.location.href = authUrl;
        return;
    }

    // Listen for login success message from popup
    const messageHandler = function(event) {
        // Security: verify message origin (in production, check event.origin)
        if (event.data && event.data.type === 'discord_login_success') {
            window.removeEventListener('message', messageHandler);

            // Popup will close itself, but check auth status
            checkAuth();
        }
    };
    window.addEventListener('message', messageHandler);

    // Poll to detect if popup was closed manually (without completing login)
    const pollTimer = setInterval(function() {
        if (popup.closed) {
            clearInterval(pollTimer);
            window.removeEventListener('message', messageHandler);
            // Check auth in case login completed but message was missed
            checkAuth();
        }
    }, 500);
}

async function logoutUser() {
    try {
        await fetch(API_URL + '/logout', {
            method: 'POST',
            credentials: 'include'
        });
        currentUser = null;
        // Also clear local display name if set
        localStorage.removeItem('displayName');
        updateAuthUI();
    } catch (error) {
        console.error('Logout failed:', error);
    }
}

function showLoginOptions(context) {
    var modal = document.getElementById('loginOptionsModal');
    modal.style.display = 'flex';
    modal.dataset.context = context;

    // Pre-fill name input if they've used a display name before
    var savedName = localStorage.getItem('displayName');
    if (savedName) {
        document.getElementById('displayNameInput').value = savedName;
    }
}

function closeLoginOptions() {
    var modal = document.getElementById('loginOptionsModal');
    modal.style.display = 'none';
}

async function claimWithName() {
    var nameInput = document.getElementById('displayNameInput');
    var displayName = nameInput.value.trim();

    if (!displayName) {
        alert('Please enter a name');
        return;
    }

    if (displayName.length < 3 || displayName.length > 20) {
        alert('Name must be 3-20 characters');
        return;
    }

    var sessionId = getSessionId();

    try {
        const response = await fetch(API_URL + '/claim-with-name', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                session_id: sessionId,
                display_name: displayName
            })
        });

        const data = await response.json();

        if (!response.ok) {
            // Show specific error message (e.g., profanity filter)
            alert(data.detail || 'Failed to claim scores');
            return;
        }

        // Success! Save the display name locally
        localStorage.setItem('displayName', displayName);

        // Create a pseudo-user object for the UI
        currentUser = {
            username: displayName,
            isLocalUser: true  // Flag to indicate this is not a Discord user
        };

        updateAuthUI();
        closeLoginOptions();

        // Show success message
        if (data.claimed_count > 0) {
            alert(`‚úì ${data.claimed_count} score(s) claimed as "${displayName}"!`);
        } else {
            alert(`‚úì Future scores will appear as "${displayName}"!`);
        }

    } catch (error) {
        console.error('Failed to claim with name:', error);
        alert('Failed to claim scores. Please try again.');
    }
}

function updateWinModalButtons() {
    var submitTimeBtn = document.getElementById('submitTimeBtn');
    var winLoginBtn = document.getElementById('winLoginBtn');
    var winLoginPrompt = document.getElementById('winLoginPrompt');

    if (currentUser && !timeSubmitted) {
        submitTimeBtn.style.display = 'inline-block';
        winLoginBtn.style.display = 'none';
        winLoginPrompt.style.display = 'none';
    } else if (!currentUser) {
        submitTimeBtn.style.display = 'none';
        winLoginBtn.style.display = 'inline-block';
        winLoginPrompt.style.display = 'block';
    } else {
        // Already submitted
        submitTimeBtn.style.display = 'none';
        winLoginBtn.style.display = 'none';
        winLoginPrompt.style.display = 'none';
    }
}

async function autoSubmitTime(timeSeconds) {
    var timeDisplay = document.getElementById('winTimeDisplay');

    try {
        timeDisplay.textContent = 'Submitting time...';

        var submissionData = {
            game_id: '729',
            submission_type: 'time',
            score: score,
            time_to_729_seconds: timeSeconds,
            seed: time,
            moves: gameRecord.moves
        };

        // Add session_id if not logged in
        if (!currentUser) {
            submissionData.session_id = getSessionId();
        }

        var response = await fetch(API_URL + '/scores', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(submissionData)
        });

        if (response.ok) {
            var data = await response.json();
            var mins = Math.floor(timeSeconds / 60);
            var secs = timeSeconds % 60;

            // Store score ID for sharing
            if (data.score_id) {
                lastSubmittedScoreId = data.score_id;
                console.log('autoSubmitTime: captured score_id =', lastSubmittedScoreId);
            } else {
                console.log('autoSubmitTime: no score_id in response', data);
            }

            if (data.anonymous) {
                // Anonymous submission - encourage login
                timeDisplay.innerHTML = `
                    ‚úì Time saved! (${mins}:${secs.toString().padStart(2, '0')})<br>
                    <span style="font-size:12px; color:#8CB84A;">Login to claim it on the leaderboard!</span>
                `;
                document.getElementById('winLoginBtn').style.display = 'inline-block';
                document.getElementById('winLoginPrompt').style.display = 'none';
            } else {
                // Logged-in submission - check ranking
                var qualifyResponse = await fetch(
                    `${API_URL}/check-qualify/time?score=${score}&time_seconds=${timeSeconds}`
                );

                if (qualifyResponse.ok) {
                    var qualifyData = await qualifyResponse.json();

                    if (qualifyData.has_any) {
                        var best = null;
                        var bestPeriodName = '';

                        if (qualifyData.qualifies.daily) {
                            best = qualifyData.qualifies.daily;
                            bestPeriodName = 'today';
                        } else if (qualifyData.qualifies.weekly) {
                            best = qualifyData.qualifies.weekly;
                            bestPeriodName = 'this week';
                        } else if (qualifyData.qualifies.all_time) {
                            best = qualifyData.qualifies.all_time;
                            bestPeriodName = 'all time';
                        }

                        if (best) {
                            timeDisplay.innerHTML = `
                                ‚úì Time submitted!<br>
                                üèÜ You're #${best.rank} ${bestPeriodName}!
                            `;
                        } else {
                            timeDisplay.textContent = `‚úì Time submitted! (${mins}:${secs.toString().padStart(2, '0')})`;
                        }
                    } else {
                        timeDisplay.textContent = `‚úì Time submitted! (${mins}:${secs.toString().padStart(2, '0')})`;
                    }
                } else {
                    timeDisplay.textContent = `‚úì Time submitted! (${mins}:${secs.toString().padStart(2, '0')})`;
                }
            }

            timeSubmitted = true;
        } else {
            var error = await response.json();
            timeDisplay.textContent = '‚úó Submission failed: ' + (error.detail || 'Unknown error');
        }
    } catch (error) {
        console.error('Error submitting time:', error);
        timeDisplay.textContent = '‚úó Error: ' + error.message;
    }
}


async function submitTime() {
    if (!currentUser || timeSubmitted || timeToWin === null) {
        console.log('Cannot submit time');
        return;
    }

    try {
        var timeDisplay = document.getElementById('winTimeDisplay');
        timeDisplay.textContent = 'Submitting time...';

        var response = await fetch(API_URL + '/scores', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_id: '729',
                submission_type: 'time',
                score: score,
                time_to_729_seconds: timeToWin,
                seed: time,
                moves: gameRecord.moves
            })
        });

        if (response.ok) {
            var data = await response.json();
            console.log('Time submitted:', data);
            timeSubmitted = true;

            // Store score ID for sharing
            if (data.score_id) {
                lastSubmittedScoreId = data.score_id;
            }

            updateWinModalButtons();

            // Fetch rank info
            try {
                var rankResponse = await fetch(API_URL + '/user/rank/time?time_period=all_time', {
                    credentials: 'include'
                });

                if (rankResponse.ok) {
                    var rankData = await rankResponse.json();
                    if (rankData.has_score) {
                        var rank = rankData.rank_info.rank;
                        var total = rankData.rank_info.total_players;
                        var mins = Math.floor(timeToWin / 60);
                        var secs = timeToWin % 60;
                        timeDisplay.innerHTML = `
                            ‚úì Time submitted!<br>
                            Rank: #${rank} of ${total} players<br>
                            Time: ${mins}:${secs.toString().padStart(2, '0')}
                        `;
                    }
                }
            } catch (e) {
                timeDisplay.textContent = '‚úì Time submitted successfully!';
            }
        } else {
            var error = await response.text();
            console.error('Failed to submit time:', error);
            timeDisplay.textContent = '‚úó Failed: ' + error;
        }
    } catch (error) {
        console.error('Time submission error:', error);
        timeDisplay.textContent = '‚úó Error: ' + error.message;
    }
}

async function autoSubmitHighScore(finalScore) {
    var statusDiv = document.getElementById('gameOverSubmissionStatus');

    try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'Submitting score...';

        console.log(`DEBUG: Submitting high score. Score=${finalScore}, Seed=${time}, Moves=${gameRecord.moves.length}`);
        console.log(`DEBUG: gameRecord =`, gameRecord);

        var submissionData = {
            game_id: '729',
            submission_type: 'high_score',
            score: finalScore,
            seed: time,
            moves: gameRecord.moves
        };

        // Add session_id if not logged in
        if (!currentUser) {
            submissionData.session_id = getSessionId();
        }

        var response = await fetch(API_URL + '/scores', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(submissionData)
        });

        if (response.ok) {
            var data = await response.json();

            // Clear saved game state since this game is now submitted
            clearSavedGameState();

            // Store score ID for sharing
            if (data.score_id) {
                lastSubmittedScoreId = data.score_id;
                console.log('autoSubmitHighScore: captured score_id =', lastSubmittedScoreId);
            } else {
                console.log('autoSubmitHighScore: no score_id in response', data);
            }

            if (data.anonymous) {
                // Anonymous submission - encourage login
                statusDiv.innerHTML = `
                    ‚úì Score saved!<br>
                    <span style="font-size:12px; color:#8CB84A;">Login to claim it on the leaderboard!</span>
                `;
                document.getElementById('gameOverLoginBtn').style.display = 'inline-block';
                document.getElementById('gameOverLoginPrompt').style.display = 'none';
            } else {
                // Logged-in submission - check ranking
                var qualifyResponse = await fetch(
                    `${API_URL}/check-qualify/high_score?score=${finalScore}`
                );

                if (qualifyResponse.ok) {
                    var qualifyData = await qualifyResponse.json();

                    if (qualifyData.has_any) {
                        var best = null;
                        var bestPeriodName = '';

                        if (qualifyData.qualifies.daily) {
                            best = qualifyData.qualifies.daily;
                            bestPeriodName = 'today';
                        } else if (qualifyData.qualifies.weekly) {
                            best = qualifyData.qualifies.weekly;
                            bestPeriodName = 'this week';
                        } else if (qualifyData.qualifies.all_time) {
                            best = qualifyData.qualifies.all_time;
                            bestPeriodName = 'all time';
                        }

                        if (best) {
                            statusDiv.innerHTML = `
                                ‚úì Score submitted!<br>
                                üèÜ You're #${best.rank} ${bestPeriodName}!
                            `;
                        } else {
                            statusDiv.textContent = `‚úì Score submitted!`;
                        }
                    } else {
                        statusDiv.textContent = `‚úì Score submitted!`;
                    }
                } else {
                    statusDiv.textContent = `‚úì Score submitted!`;
                }
            }
        } else {
            var error = await response.json();
            statusDiv.textContent = '‚úó Submission failed: ' + (error.detail || 'Unknown error');
        }
    } catch (error) {
        console.error('Error submitting score:', error);
        statusDiv.textContent = '‚úó Error: ' + error.message;
    }
}


async function submitHighScore() {
    var finalScore = score;

    if (!currentUser) {
        return;
    }

    var statusDiv = document.getElementById('gameOverSubmissionStatus');
    var submitBtn = document.getElementById('gameOverSubmitBtn');
    submitBtn.style.display = 'none';

    try {
        statusDiv.style.display = 'block';
        statusDiv.textContent = 'Submitting score...';

        var response = await fetch(API_URL + '/scores', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                game_id: '729',
                submission_type: 'high_score',
                score: finalScore,
                seed: time,
                moves: gameRecord.moves
            })
        });

        if (response.ok) {
            var data = await response.json();
            console.log('High score submitted:', data);

            // Fetch rank info
            try {
                var rankResponse = await fetch(API_URL + '/user/rank/high_score?time_period=all_time', {
                    credentials: 'include'
                });

                if (rankResponse.ok) {
                    var rankData = await rankResponse.json();
                    if (rankData.has_score) {
                        var rank = rankData.rank_info.rank;
                        var total = rankData.rank_info.total_players;
                        statusDiv.innerHTML = `
                            ‚úì Score submitted!<br>
                            Rank: #${rank} of ${total} players<br>
                            Score: ${finalScore.toLocaleString()}
                        `;
                    }
                }
            } catch (e) {
                statusDiv.textContent = '‚úì Score submitted successfully!';
            }
        } else {
            var errorText = await response.text();
            console.error('Failed to submit high score:', errorText);
            statusDiv.textContent = '‚úó Failed to submit score: ' + errorText;
            statusDiv.style.background = 'rgba(255,107,107,0.2)';
        }
    } catch (error) {
        console.error('High score submission error:', error);
        statusDiv.textContent = '‚úó Error submitting score: ' + error.message;
        statusDiv.style.background = 'rgba(255,107,107,0.2)';
    }
}

// Check auth on page load
checkAuth();

values = nextValues.slice()
update = true

checkGameOver()
drawLoop()
//console.log(values
	
console.log('hello logcat??')


// case 0 [9, 2, 3, 13] ( this isn't right )
</script>

