<title>729</title>

<div id="container">
<canvas id="tileCanvas"></canvas>
<canvas id="bgtileCanvas"></canvas>
<canvas id="arrowCanvas"></canvas>
<canvas id='background'></canvas>

<div id="title">
<h1>729</h1>
</div>
<div id ="instructions">
<p>Line up three matching numbers and swipe them together. Get a <b>729</b> tile to win.</p>
</div>
<div id ="gameOver">
    <div id ="inner1">
        <p>Game over! Your score is 0.</p>
    </div>
<button onclick="newGame()" class="button">New Game</button>
<button onclick="toClipboard(true)" class="button3">Share (clipboard)</button>
</div>

<div id ="youWin">
    <div id ="inner2">
        <p">You won!</p>
    </div>
<button onclick="continueGame()" class="contButton">Continue?</button>
<button onclick="toClipboard(false)" class="button3">Share (clipboard)</button>
</div>

<div id ="score" onclick="toggleScore()">
    <p">Score: </p>
</div>

<button onclick="newGame()" class="button2"> New Game </button>

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_donations" />
<input type="hidden" name="business" value="3YMPULTFTQ3NN" />
<input type="hidden" name="item_number" value="729 Puzzle Donation" />
<input type="hidden" name="currency_code" value="USD" />
<input type="image" id='paypalImg' type="image" style="position:absolute; right:15%; top:90%; z-index:50 ;border: 0px none ; padding: 0px; height:10vw;" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" title="PayPal - The safer, easier way to pay online!" alt="Donate with PayPal button" />
<img alt="" border="0" src="https://www.paypal.com/en_US/i/scr/pixel.gif" width="1" height="1" />
</form>

<div id="twitterDesc">
<p>Stay in touch for the next project!</p>
</div>


<script src="https://platform.twitter.com/widgets.js"></script>
<a href="https://twitter.com/intent/follow?screen_name=Aeium"  ><img id='twitlinkPic' style="position:absolute; left:20%; top:92.4%; z-index:50;  border: 0px none ; padding: 0px; height:4.5vw" src="graphics/follow_aeium.png" /></a>

</div>

<link rel="stylesheet" href="fonts/stylesheet1.css" type="text/css" charset="utf-8" />
<link rel="stylesheet" href="fonts/kit2/stylesheet.css" type="text/css" charset="utf-8" />

<style>

//     top: 68%;
//    left: 5%;
//    right: 52%;
//    margin: 2vw;
//    font-size: 5.5vw;

// z index notes: https://css-tricks.com/forums/topic/safari-for-ios-z-index-ordering-bug-while-scrolling-a-page-with-a-fixed-element/

* {
    overflow:hidden
    touch-action: none
    box-sizing: border-box
} 

html {
  height: 100%;
  width: 100%;
  overflow: hidden;
  -webkit-overflow-scrolling: auto;
}

#twitter-widget-0{

    position:absolute; 
    right:13% !important;
    top:87% !important;
    z-index:50 !important;
    border: 0px none ; 
    padding: 0px; 
    height:30vw "

}

body { 

    top:0;
    left:0;
    //position: fixed;

  height: 100%;
  scrollHeight: 100%;
  padding: 0;
  overflow: hidden;
  margin: 0;
  -webkit-overflow-scrolling: auto;
	font-family: 'OmegleRegular';					

    //overscroll-behavior: contain;

    //   margin: 0; 
    //   padding: 0
    //}
#container{


    -webkit-overflow-scrolling: auto;
    height:100% -1px; overflow:hidden;
}

#tileCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#bgtileCanvas { 
     background-color: #222529;
     position: absolute;
     left: 0;
     top: 0;
     z-index: -1;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#arrowCanvas { 
     position: absolute;
     left: 0;
     top: 0;
     z-index: 0;
     width: 100%; 
     height: 100%; 
     overflow: hidden
   }
#title {
    position: absolute;
    top: -3%;
    left: 0;
    right: 0;
    margin: 0;//auto;
    z-index: 100;
    font-size: 13vw;
    color: #D1D2D3;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
    text-shadow: -4px -4px 0 #000, 4px -4px 0 #000, -4px 4px 0 #000, 4px 4px 0 #000;
    user-select: none;
}
#instructions {  

    position: absolute;
    top: 78%;
    left: 0;
    right: 0;
    margin: auto;
    font-size: 4vw;
    z-index: 100;
    color: #D1D2D3;
    display: inline-block;
    vertical-align: middle;
    text-align: center;
}
#twitterDesc {  

    position: absolute;
    top: 88%;
    left: 15%;
    right: 0;
    margin: auto;
    font-size: 2vw;
    //display: inline-block;
    //vertical-align: middle;
    //text-align: center;
}
#gameOver { 

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;
    
    display: none; 
    
    z-index: 50;
    background-color:#D1D2D3;
    position: absolute;
    top: 40%;
    left: 20%;
    right: 20%;
    margin: auto;
    font-size: 4vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
}

#youWin { 

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 2vw;
    
    display: none; 
   
    z-index: 50; 
    background-color:white;
    position: absolute;
    top: 40%;
    left: 20%;
    right: 20%;
    margin: auto;
    font-size: 4vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: center;
}
.button {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    z-index: 50;
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    border: none;
    color: rgb(40, 40, 40);;
    padding: 2vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'OmegleRegular';
    font-size: 4vw;
}

.button2 {  
    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    z-index: 50;
    color: rgb(40, 40, 40);
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    position: absolute;
    text-decoration: none;
    top: 70%;
    left: 52%;
    right: 5%;
    margin: 2vw;
    font-family: 'OmegleRegular';
    font-size: 5.5vw;
    vertical-align: middle;
    text-align: right;
}
.button3 {  

    border-radius: 1.5vw;
    border: 1vw solid #000000;
    padding: 1.5vw;
z-index: 50;
background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
border: none;
color: rgb(40, 40, 40);
padding: 2vw;
text-align: center;
text-decoration: none;
display: inline-block;
font-family: 'OmegleRegular';
font-size: 4vw;
}
.contButton {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    z-index: 50;
    background: linear-gradient(to bottom, rgba(140,184,74,1), rgba(112,157,68,1));
    border: none;
    color: rgb(40, 40, 40);;
    padding: 2vw;
    text-align: center;
    text-decoration: none;
    display: inline-block;
    font-family: 'OmegleRegular';
    font-size: 4vw;
}
#score {  

    border-radius: 2vw;
    border: 1vw solid #000000;
    padding: 2vw;
    
    display: inline-block; 
    
    z-index: 50;
    background-color:#D1D2D3;
    position: absolute;
    top: 70%;
    left: 5%;
    right: 52%;
    margin: 2vw;
    font-size: 5.5vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;
   
}
#reset {   // I don't think this element actually exists try to remove later one thing at a time for now

    border-radius: 2.5vw;
    border: .5vw solid #000000;
    padding: 0vw;
    
    display: inline-block; 
    
    background-color: black; //#4CAF50; /* Green */
    position: absolute;
    top: 71%;
    left: 52%;
    right: 5%;
    margin: auto;
    font-size: 5vw;
    //display: inline-block;
    vertical-align: middle;
    text-align: left;

</style>
<script src="https://cdn.jsdelivr.net/npm/sketch-js@1.1.3/js/sketch.min.js"></script>

<script>
// https://gist.github.com/joates/6584908
function linspace(a,b,n) {
    if(typeof n === "undefined") n = Math.max(Math.round(b-a)+1,1);
    if(n<2) { return n===1?[a]:[]; }
    var i,ret = Array(n);
    n--;
    for(i=n;i>=0;i--) { ret[i] = (i*b+(n-i)*a)/n; }
    return ret;
}
var angles = linspace(0,Math.PI * 2, 7)
var slice  = Math.PI / 6
function mod(n, m) {
        return ((n % m) + m) % m;
}


var count = 0 

var colR1  = [12,13,14]
var colR2  = [11,3,4,15]
var colR3 = [10,2,0,5,16]
var colR4  = [9,1,6,17]
var colR5  = [8,7,18]

var colG1  = [10,11,12]
var colG2  = [9,2,3,13]
var colG3 = [8,1,0,4,14]
var colG4  = [7,6,5,15]
var colG5  = [18,17,16]

var colB1  = [8,9,10]
var colB2  = [7,1,2,11]
var colB3 = [18,6,0,3,12]
var colB4  = [17,5,4,13]
var colB5  = [16,15,14]

var colList = [] 

var values     = new Array(19).fill(0)
var nextValues = new Array(19).fill(0)
var slides     = new Array(19).fill(0)
var pops       = new Array(19).fill(0)

var prompt = false
var won    = false

var slideValue  = []
var slide       = false
var update      = true
var first       = true  // keep animating before the first move to load the font
    
var actionQueue = []
    
var slideStartX = []
var slideStartY = []
    
var deltaX = []
var deltaY = []
    
var steps = 30
var step  = 0
var games = 0

// https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
var LCG=s=>()=>(2**31-1&(s=Math.imul(48271,s)))/2**31;
var time = Math.round((new Date()).getTime() / 1000);
var rand = LCG(time)

var gameRecord = {'time': time,
                   'moves' : []}

// ctx is the context to add the path to
// points is a array of points [{x :?, y: ?},...
// radius is the max rounding radius 
// this creates a closed polygon.
// To draw you must call between 
//    ctx.beginPath();
//    roundedPoly(ctx, points, radius);
//    ctx.stroke();
//    ctx.fill();
// as it only adds a path and does not render. 
function roundedPoly(ctx, points, radiusAll) {
  var i, x, y, len, p1, p2, p3, v1, v2, sinA, sinA90, radDirection, drawDirection, angle, halfAngle, cRadius, lenOut,radius;
  // convert 2 points into vector form, polar form, and normalised 
  var asVec = function(p, pp, v) {
    v.x = pp.x - p.x;
    v.y = pp.y - p.y;
    v.len = Math.sqrt(v.x * v.x + v.y * v.y);
    v.nx = v.x / v.len;
    v.ny = v.y / v.len;
    v.ang = Math.atan2(v.ny, v.nx);
  }
  radius = radiusAll;
  v1 = {};
  v2 = {};
  len = points.length;
  p1 = points[len - 1];
  // for each point
  for (i = 0; i < len; i++) {
    p2 = points[(i) % len];
    p3 = points[(i + 1) % len];
    //-----------------------------------------
    // Part 1
    asVec(p2, p1, v1);
    asVec(p2, p3, v2);
    sinA = v1.nx * v2.ny - v1.ny * v2.nx;
    sinA90 = v1.nx * v2.nx - v1.ny * -v2.ny;
    angle = Math.asin(sinA);
    //-----------------------------------------
    radDirection = 1;
    drawDirection = false;
    if (sinA90 < 0) {
      if (angle < 0) {
        angle = Math.PI + angle;
      } else {
        angle = Math.PI - angle;
        radDirection = -1;
        drawDirection = true;
      }
    } else {
      if (angle > 0) {
        radDirection = -1;
        drawDirection = true;
      }
    }
    if(p2.radius !== undefined){
        radius = p2.radius;
    }else{
        radius = radiusAll;
    }
    //-----------------------------------------
    // Part 2
    halfAngle = angle / 2;
    //-----------------------------------------

    //-----------------------------------------
    // Part 3
    lenOut = Math.abs(Math.cos(halfAngle) * radius / Math.sin(halfAngle));
    //-----------------------------------------

    //-----------------------------------------
    // Special part A
    if (lenOut > Math.min(v1.len / 2, v2.len / 2)) {
      lenOut = Math.min(v1.len / 2, v2.len / 2);
      cRadius = Math.abs(lenOut * Math.sin(halfAngle) / Math.cos(halfAngle));
    } else {
      cRadius = radius;
    }
    //-----------------------------------------
    // Part 4
    x = p2.x + v2.nx * lenOut;
    y = p2.y + v2.ny * lenOut;
    //-----------------------------------------
    // Part 5
    x += -v2.ny * cRadius * radDirection;
    y += v2.nx * cRadius * radDirection;
    //-----------------------------------------
    // Part 6
    ctx.arc(x, y, cRadius, v1.ang + Math.PI / 2 * radDirection, v2.ang - Math.PI / 2 * radDirection, drawDirection);
    //-----------------------------------------
    p1 = p2;
    p2 = p3;
  }
  ctx.closePath();
}

function hexagon(x, y, ctx, value){
   
    var fill = false

    if(value != 0){
        fill = true
    }
   
    ret = offset2(x, y, 0 , circleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]

    var points = []
    
    //points.push({x: ret[0],y: ret[1]})
    
    //points.push

    var yTop = cornerY
    var yBot = cornerY - circleSize/2

    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]

        //if(cornerY > yTop){yTop = cornerY}
        //if(cornerY < yTop){yBot = cornerY}
        
        points.push({x: ret[0],y: ret[1]})
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }

    colors = getColor(value)

    var gradient = ctx.createLinearGradient(0,yTop,0,yBot)
    //gradient.addColorStop(0,"rgba(0,0,0,1)")//colors[0])
    gradient.addColorStop(0,colors[1])
    gradient.addColorStop(1,colors[0])

    ctx.fillStyle = gradient
    
    //ctx.fillStyle = 'black'
    
    //console.log(points)
    
    
    
    ctx.strokeStyle = 'black'
    
    if(isSafari){
        ctx.lineWidth = 1
        
        if(value != 0){
            ctx.lineWidth += 2
        }
    } else {
        ctx.lineWidth = 3
        
        if(value != 0){
            ctx.lineWidth += 6
        }
    
    }
    ctx.beginPath()

    roundedPoly(ctx, points, circleSize/8)

    ctx.fill()
    
    //if(value != 0){
    ctx.stroke()
    //}

    
    //if(mod(value,2) == 0 && value != 0){
    //    ctx.fillStyle = "#000000"
    //}
    
    //console.log(getColor(value))
    //console.log(getColorInv(value))
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = getColorInv(value)[0]; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()
}

function hexagonOld(x, y, ctx, value){
   
    var fill = false
    
    //console.log(fill)
    //console.log(x)
    //console.log(y)

    var fillG = 0
    var fillR = 0
    if(value % 6 == 0){
        fillR = mod(value * 50,255)
    } else {
    
        fillG = mod(value * 51,255)
    }

    var fillB = mod(value * 61,255)//Math.floor(mod((value / 81) * 255,255))
   
    if(value != 0){
    
        fill = true
        ctx.fillStyle = "rgba(" +fillR + "," +fillG + "," +fillB + ", 1)"; 
    }else {
    
        ctx.fillStyle = "rgba(245,245,220, 1)";
    
    }
   
    //console.log(fillB)
   
    // this is more complicated now because of curved corners
    // if you want to see how the basic version works look at the old function
   
    var radius = circleSize /10
   
    ctx.beginPath()
    ret = offset2(x, y, 0 , circleSize/2)  // starting from angle 4 makes the hexagon in the proper place (I think)
    var cornerX = ret[0]
    var cornerY = ret[1]
    ret = offset2(cornerX, cornerY, 4 , circleSize/10)
    var curveX1 = ret[0]
    var curveY1 = ret[1]
    //ctx.fillText("cu1",curveX1 , curveY1)
    //ctx.fillText("co1",cornerX , cornerY)
    
    var arcRets = []
    
    ctx.moveTo(curveX1, curveY1)
    for(var h = 0; h < 6; h++){
        
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/10)
        curveX2 = ret[0]
        curveY2 = ret[1]
        //ctx.fillText("cu"+h,curveX2 , curveY2)
        //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
        ctx.lineTo(curveX2,curveY2)
        
        arcRets.push(towards(cornerX,cornerY,x,y,radius+2))
       
        ret = offset2(cornerX, cornerY, directions[h] , circleSize*4/10)
        curveX1 = ret[0]
        curveY1 = ret[1]
        ctx.lineTo(curveX1,curveY1)
        ret = offset2(cornerX, cornerY, directions[h] , circleSize/2)
        cornerX = ret[0]
        cornerY = ret[1]
        //ctx.fillText("cu"+h,curveX1 , curveY1)
        //ctx.fillText("co"+h,cornerX , cornerY)
    }
    
    var colorString = "rgb("+fillR+ "," + fillG + "," + fillB +")"
    
    ret = offset2(cornerX, cornerY, directions[h] , circleSize/20)
    curveX2 = ret[0]
    curveY2 = ret[1]
    
    //ctx.quadraticCurveTo(cornerX,cornerY, curveX2,curveY2)
    ctx.closePath()
    

    //console.log(ctx.fillStyle)
    ctx.fill()
    
    if(mod(value,2) == 0 && value != 0){
        ctx.fillStyle = "#000000"
    }
    
    for(var h = 0; h < 6; h++){
        ctx.beginPath()
        ctx.arc(arcRets[h][0], arcRets[h][1], radius, 0,6.3)
        ctx.closePath()
        ctx.fill()
        //ctx.stroke()
    }
    
    
    if(fill){
        var digits = value.toString().length
    
        ctx.fillStyle = "rgba(" + (255-fillR) + "," +(255-fillG) + "," +(255-fillB) + ", 1)"; 
        
        //https://stackoverflow.com/questions/13771310/center-proportional-font-text-in-an-html5-canvas
        ctx.textBaseline = 'middle';
        ctx.textAlign = "center";
        ctx.fillText(value.toString(), x , y )
    }
   //ctx.stroke()
}

function towards(x1,y1,x2,y2,distance){

    var diffX = x2 - x1
    var diffY = y2 - y1

    var mag = Math.sqrt(diffX*diffX + diffY*diffY)
    var outX = x1 + diffX * distance / mag
    var outY = y1 + diffY * distance / mag
    
    return [outX,outY]
}

// these two use the angle number to look up the exact angle from the angles list
function offset(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle] + slice)) * factor
    retY = y + (Math.cos(angles[angle] + slice)) * factor
    
    return [retX,retY]
}
function offset2(x, y, angle, factor){
    retX = x + (Math.sin(angles[angle])) * factor
    retY = y + (Math.cos(angles[angle])) * factor
    
    return [retX,retY]
}
// this one uses the angle in radians instead of a lookup index
function offsetExact(x, y, angle, factor){
    retX = x + (Math.sin(angle + slice)) * factor
    retY = y + (Math.cos(angle + slice)) * factor
    
    return [retX,retY]
}

var score = 0

// these are not in order sorry. background < bgtile < tile < arrow

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");
var canvas4 = document.getElementById("background");
var ctx4    = canvas4.getContext("2d");


var userAgent = window.navigator.userAgent;
var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))

var height = null
var width  = null

/*
if( window.innerHeight < screen.height){
    height = window.innerHeight
} else {
    height = screen.height
}
if( window.innerWidth < screen.width){
    width = window.innerWidth
} else {
    width = screen.width
}*/

var min = width

var circleSize = width / 5
var directions = [2,3,4,5,0,1]
var posX = []
var posY = []

var fontSize = circleSize/2.5

var smoke = false
var smokeFrame = 0

ctx1.font= fontSize.toString() + 'px OmegleRegular';
ctx2.font= fontSize.toString() + 'px OmegleRegular';
ctx3.font= fontSize.toString() + 'px OmegleRegular';

var score      = 0
var startTime  = 0
var startDate  = Date.now()

var displayTime = false

var scoreDiv = document.getElementById("score");
scoreDiv.innerText ="Score: " + score.toString()

function initCanvas(){

var canvas1 = document.getElementById("tileCanvas");
var ctx1    = canvas1.getContext("2d");
var canvas2 = document.getElementById("bgtileCanvas");
var ctx2    = canvas2.getContext("2d");
var canvas3 = document.getElementById("arrowCanvas");
var ctx3    = canvas3.getContext("2d");
var canvas4 = document.getElementById("background");
var ctx4    = canvas4.getContext("2d");

    var userAgent = window.navigator.userAgent;
    var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))
    if (isSafari){
    

        height = screen.height *.9//window.innerHeight
        width = screen.width//window.innerWidth


        ctx1.canvas.width  = screen.width//window.innerWidth  -1; //width//
        ctx1.canvas.height = screen.height *.9//window.innerHeight -1; //height//
        ctx2.canvas.width  = screen.width //window.innerWidth  -1; // width//
        ctx2.canvas.height = screen.height *.9//window.innerHeight -1; // height//
        ctx3.canvas.width  = screen.width//window.innerWidth  -1;  // width//
        ctx3.canvas.height = screen.height *.9//window.innerHeight -1; // height//
        ctx4.canvas.width  = screen.width//window.innerWidth  -1;  // width//
        ctx4.canvas.height = screen.height *.9//window.innerHeight -1; // height//
    } else {
        height = window.innerHeight *.9
        width = window.innerWidth

        ctx1.canvas.width  = window.innerWidth  ; //width//
        ctx1.canvas.height = window.innerHeight *.9; //height//
        ctx2.canvas.width  = window.innerWidth  ; // width//
        ctx2.canvas.height = window.innerHeight *.9; // height//
        ctx3.canvas.width  = window.innerWidth  ;  // width//
        ctx3.canvas.height = window.innerHeight *.9; // height//
        ctx4.canvas.width  = window.innerWidth  ;  // width//
        ctx4.canvas.height = window.innerHeight *.9; // height//
    
    }
    
        //console.log(height)
        //console.log(width)
    
    canvas3.style.zIndex = 40
    canvas1.style.zIndex = 30    // wooooow fuck that everything online had a dash in z-index for the css but it didn't actually have a dash
    canvas2.style.zIndex = 20
    canvas4.style.zIndex = 10

    //https://www.quirksmode.org/dom/w3c_cssom.html 
    //console.log(angles)
    //console.log(slice)

    var canvasLeft = canvas1.offsetLeft;
    var canvasTop  = canvas1.offsetTop;
    var count = 0

    
    min = width
    
    ratio = width / height
    console.log(ratio)
    
    if(width+400 > height){
    
        ratio = (width / height) * 2 // seems about right
        // elements that need font prop change
        // #reset {  #score {  .contButton {  .button2 {  .button {   #youWin {  #gameOver {   #instructions {  #title
        min = width / ratio
        
        var resizes = []
        
        //resizes.push(document.getElementById('reset'))
        resizes.push(document.getElementById('score'))
        resizes.push(document.getElementsByClassName("contButton")[0])
        resizes.push(document.getElementsByClassName('button2')[0])
        resizes.push(document.getElementsByClassName('button')[0])
        resizes.push(document.getElementById('youWin'))
        resizes.push(document.getElementById('gameOver'))
        resizes.push(document.getElementById('instructions'))
        resizes.push(document.getElementById('title'))
        resizes.push(document.getElementById('twitterDesc'))
        resizes.push(document.getElementById('twitlinkPic'))
        resizes.push(document.getElementById('paypalImg'))
        resizes.push(document.getElementsByClassName('button3')[0])
        
        //console.log(resizes)
        
        for(var i = 0; i < resizes.length; i++){
        
            oldSize = parseFloat(getComputedStyle(resizes[i])['font-size'])
            resizes[i].style.fontSize  = (oldSize / ratio).toString() + 'px'
            //console.log(getComputedStyle(resizes[i]))
            
        }
        
        // this is all janky but idk the better way to do it yet
        
        var scoreStyle    = resizes[0].style
        var restartStyle  = resizes[2].style
        var instructions  = resizes[6].style
        var twitDesc      = resizes[8].style
        var twitPic       = resizes[9].style
        var paypalImg     = resizes[10].style
        
        scoreStyle.position   = 'absolute'
        restartStyle.position = 'absolute'
        instructions.position = 'absolute'
        
        scoreStyle.left     = '27%'
        restartStyle.right  = '20%'
        
        scoreStyle.top     = '63%'
        restartStyle.top   = '63%'
        
        scoreStyle.border    = '.2vw solid #000000'
        restartStyle.border  = '.2vw solid #000000'
        
        twitDesc.left      = '35%'
        twitDesc.top       =  '86%'
        twitDesc.fontSize  = '.8vw'
        
        twitPic.left       =  '35%'
        twitPic.height     = '2.5vw'
        twitPic.top        = '92%'
        
        paypalImg.right    = '31.5%'
        paypalImg.height   = '5vw'
        
        instructions.top = '80%'
        
    } else{
        scale = ratio

        title = document.getElementById('title')

        scale = scale * 10
        font_s = 17 - scale
        title.style.fontSize = font_s + "vw"
    }
    
    if(isSafari){
        circleSize = Math.floor(min / 5.4)
        var drawX = width/2//520
        var drawY = height*.4  //520
    }
    else {
        circleSize = Math.floor(min / 5)
        var drawX = width/2//520
        var drawY = height*.4  //520
    }
    
    directions = [2,3,4,5,0,1]
    
    fontSize = circleSize/2.5

    ctx1.font= fontSize.toString() + 'px OmegleRegular';
    ctx2.font= fontSize.toString() + 'px OmegleRegular';
    ctx3.font= fontSize.toString() + 'px OmegleRegular';
    
    //ctx1.fillStyle = 'black'
    //ctx1.fillRect(drawX,drawY,100,100)
    
    posX = []
    posY = []
    posX.push(drawX)
    posY.push(drawY)
    for(var i = 0; i < 12; i++){
            
        for(var j = 0; j < i*6; j++){
        
        
            ret = offset(drawX, drawY, directions[Math.floor(j / i)], circleSize)
            drawX = ret[0]
            drawY = ret[1]
            posX.push(drawX)
            posY.push(drawY)
           
        }
        
        ret = offset(drawX, drawY, 6, circleSize)
        drawX = ret[0]
        drawY = ret[1]
    }
    
    //console.log(posX)
    //console.log(posY)

    console.log(title.style.fontSize)


}

function hidewideScreenStuff(){

        wideScreen_instruct = document.getElementById("wideScreen_instruct")
        
        wideScreen_instruct.style.display = 'none'
        
        console.log(wideScreen_instruct.style)

}

function formatTime(obj){
    var x=[];
    x.push(obj.m);
    x.push(obj.s);
    return x.join(':')
}

var bgcount = 9999990
var prevTime  = 0
var finalTime = -1

function secs2Time(secs) {
var minutes = Math.floor(secs / 60);
var seconds = Math.floor(secs % 60);
var obj = {
"m": minutes.toString().length === 1 ? '0' + minutes : minutes,
"s": seconds.toString().length === 1 ? '0' + seconds : seconds
};
return obj;
}

//🟪🟦🟩🟨🟧🟥🟫⬜
// ⬛🟨🟩


function get_square(value){
    if(value > 729){
        value = value / 729
    }
    var value_chars = {
        0:"⬛",
        3:"🟦",
        9:"🟩",
        27:"🟨",
        81:"🟧",
        243:"🟥",
        729:"🟪",
    }
    return value_chars[value]
}

function getColor_tup(value){

    if(value > 729){
        value = value / 729
    }
    var value_to_rgb = {
        0:[[92,92,92],[40,40,40]],
        3:[[82,159,237],[57,126,213]],
        9:[[140,184,74],[112,157,68]],
        27:[[250,227,67],[242,192,57]],
        81:[[239,157,46],[233,127,45]],
        243:[[222,72,58],[186,53,47]],
        729:[[159,75,182],[117,56,147]]
    }   

    return value_to_rgb[value]
}

function getColor(value){
    if(value == 1){value = 0}
    tuples = getColor_tup(value)

    c1 = tuples[0]
    c2 = tuples[1]

    c1s = "rgba(" + c1[0] + "," + c1[1] + "," + c1[2] + ", 1)"
    c2s = "rgba(" + c2[0] + "," + c2[1] + "," + c2[2] + ", 1)"

    return [c1s,c2s]
}

function getColorInv(value){
    //if(value == 1){value = 0}
    //tuples = getColor_tup(value)

    //c1_o = tuples[0] // original color before invert
    //c2_o = tuples[1]

    //c1 = [255 - c1_o[0], 255- c1_o[1], 255 - c1_o[2] ]  // perform invert
    //c2 = [255 - c2_o[0], 255- c2_o[1], 255 - c2_o[2] ]

    //c1s = "rgba(" + c1[0] + "," + c1[1] + "," + c1[2] + ", 1)" // color string
    //c2s = "rgba(" + c2[0] + "," + c2[1] + "," + c2[2] + ", 1)"

    return ["rgba(" + 40 + "," + 40 + "," + 40 + ", 1)"]
}


function text_board(){

    //var colG1  = [10,11,12]
    //var colG2  = [9,2,3,13]
    //var colG3 = [8,1,0,4,14]
    //var colG4  = [7,6,5,15]
    //var colG5  = [18,17,16]

    var today = new Date();
    var dd = String(today.getDate()).padStart(2, '0');
    var mm = String(today.getMonth() + 1).padStart(2, '0'); //January is 0!
    var yyyy = today.getFullYear();

    today = mm + '/' + dd + '/' + yyyy;

    var board_string = "729 - "+ today + "\n      "
    for (var i = colG1.length-1; i >= 0; i--){
        board_string += get_square(values[colG1[i]])
    }
    board_string += "      \n   "
    for (var i = colG2.length-1; i >= 0; i--){
        board_string += get_square(values[colG2[i]])
    }
    board_string += "   \n"
    for (var i = colG3.length-1; i >= 0; i--){
        board_string += get_square(values[colG3[i]])
    }
    board_string += "\n   "
    for (var i = colG4.length-1; i >= 0; i--){
        board_string += get_square(values[colG4[i]])
    }
    board_string += "   \n      "
    for (var i = colG5.length-1; i >= 0; i--){
        board_string += get_square(values[colG5[i]])
    }
    board_string += "      \n"

    //console.log(board_string)


    return board_string

}


var shift = 0
var shift2 = 0
function drawLoop(){

    //console.log("drawstuff"
    
    //drawBackground(Math.floor(Math.om() * 95))
    
    if(smoke){
        if(smokeFrame == 10){
            smokeFrame = 0
            smoke      = false
            ctx3.clearRect(0,0,canvas1.width,canvas1.height)
        } else {
            drawSmoke()
            smokeFrame += 1
            ctx3.globalAlpha =  1 - (smokeFrame / 10)
        }
    }

    if(displayTime && ! won){
        
        var currentTime = Math.round((new Date()).getTime() / 1000)
        if(currentTime != prevTime){
        
            var scoreDiv = document.getElementById("score");
            var runDate = Date.now() - startDate 
            //console.log(runDate)
            scoreDiv.innerText ="Time: " + formatTime(secs2Time((runDate)/1000))
            prevTime = currentTime
            finalTime = runDate
        }

    }
    
    if(update || first){
    
        ctx1.clearRect(0,0,canvas1.width,canvas1.height)
        ctx1.fillStyle='black'
        ctx1.lineStyle='black'

        count = 0
        drawX = 0
        drawY = 0
        
        var updateScore = false
        
        if(step >= steps - 5){
        
            smoke = true
        
        }
        
        if(step >= steps){
            slide = false
            update = false      // after this we don't need to continue redrawing until we get another input
            updateScore = true  // but we do need to display the new score after we sum it below
            step  = 0
            values = nextValues.slice()

            next = actionQueue.shift()
            
            //console.log(pops)
            
            for(var i = 0; i < pops.length; i++){
                if(pops[i] == 1){
                    smoke = true
                }
            }
            
            if(next){
                actionByKeyCode(next)
            }
            
            actionQueue = [] // maybe just queueing 1 is better
            
        }
        
        var winBool = false
        
        //score = 0
        
        var zeros = 0
        for(var i = 0; i<values.length;i++){
        
            var value = values[i]
            if(value == 0){
                zeros += 1 // zeros++ doesn't seem right with no semicolon
            }
            if(value == 729 && won == false){
                winBool = true
            }
        }
        
        
        if(!displayTime && (updateScore || toggleScoreFlag)){

            var scoreDiv = document.getElementById("score");
            scoreDiv.innerText ="Score: " + score.toString()
           
           toggleScoreFlag = false
           
        }
        
        if(winBool){
            first  = false   // this won't ever matter in practice but helps development
            prompt = true
            update = false
            youWin()
        }
        
        var gameOverBool = false
        
        if(zeros == 0){
        
            if(checkGameOver()){
            
                first  = false   // this won't ever matter in practice but helps development
                prompt = true
                update = false
                gameOver()
            }
        }
        
        if(slide){
                //for(var i = 1; i < 19; i++){  //posX.length
                //    hexagon(posX[i], posY[i], ctx1, 0)// + "|" + i.toString()) //values[i])
                //}
                
                // var slideValue  = [] 
                // var slideStartX = []
                // var slideStartY = []
                // var deltaX = []
                // var deltaY = []
                //var steps = 200
                //var step  = 0
                
                for(var i = 0; i < slideValue.length; i++){
                
                    if(slideValue[i] != -1){
                
                        hexagon(slideStartX[i] + deltaX[i] * step,
                                slideStartY[i] + deltaY[i] * step,
                                ctx1,
                                slideValue[i])
                            
                    }
                }
                
                step = step + 1 // I like this better than ++ now. You can tell at a glance it's doing assignment
        } else {
            update = false
            for(var i = 0; i < 19; i++){  //posX.length
                if(values[i] != 0){
                    hexagon(posX[i], posY[i], ctx1, values[i])// + "|" + i.toString()) //values[i])
                }
            }
        }
    
    }

    window.requestAnimationFrame(drawLoop)
    
}

var smokeList = []
var numSmokes = 20 // particles per pop

function Particle( x, y, radius, color, scale ) {
     this.init( x, y, radius, color, scale );
     //console.log(this)
}

Particle.prototype = {
    init: function( x, y, radius, color, scale ) {
        this.alive = true;
        this.radius = radius || 10;
        this.wander = 1.15;
        this.theta = Math.random() * Math.PI * 2;
        this.drag = 0.92;
        this.color = color
        this.x = x || 0.0;
        this.y = y || 0.0;
        this.vx = 0.0;
        this.vy = 0.0;
        this.scale = scale;
    },
    move: function() {
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.drag;
        this.vy *= this.drag;
        this.theta += (Math.random()-.5) * this.wander;
        this.vx += Math.sin( this.theta ) * 0.3;
        this.vy += Math.cos( this.theta ) * 0.3 - .02;
        this.radius *= this.scale;
        this.alive = this.radius > 0.5;
    },
    draw: function( ctx ) {
    
        //console.log('drawing particle ' + this.x + "  " + this.y)
        ctx.beginPath();
        ctx.arc( this.x, this.y, this.radius, 0, Math.PI * 2 );
        ctx.fillStyle = this.color;
        ctx.fill();
    }
};

var parity = 0
var backgroundNum = 18
var bgStarts  = []  // we data oriented
var bgVectors = []
var bgSteps   = []
var bgColors  = []


var pastels = ['#ffb3ba', '#ffdfba', '#ffffff', '#ffffba', '#baffc9', '#bae1ff', '#ffffff']
var pastels2 =  ['#b3b3b3', '#dfdfdf', '#ffffff', '#c9c9c9', '#8a8a8a']

//console.log({deltaCount:0,end: Math.floor(Math.random() * 3000)})
//console.log(Math.floor(Math.random() * 3000))
//console.log((Math.random() * 3000))

var toggleScoreFlag = false

function toggleScore(){

    console.log(displayTime)

    displayTime = ! displayTime
    toggleScoreFlag = true
}

function drawBackground(shape){

    //ctx4.clearRect(0,0,width,height)
    ctx4.globalCompositeOperation="xor"
    ctx4.fillStyle = 'white'
    ctx4.globalAlpha = .01
    ctx4.fillRect(0,0,width,height)
    //"xor";
    
    var maxVal = Math.max(...values)
    
    //console.log(maxVal)
    
    ctx4.globalAlpha = Math.min(maxVal / 1000, .34) 
    
    //console.log(ctx4.globalAlpha)
    
    if(bgStarts.length == 0){
    
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        bgStarts.push(fiveAbove())
        
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        bgSteps.push({deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)})
        
        //console.log(bgSteps)
        
        bgSteps[0].deltaCount = Math.floor(Math.random() * bgSteps[0].end)  // so they don't all start at the top
        bgSteps[1].deltaCount = Math.floor(Math.random() * bgSteps[1].end)
        bgSteps[2].deltaCount = Math.floor(Math.random() * bgSteps[2].end)
        bgSteps[3].deltaCount = Math.floor(Math.random() * bgSteps[3].end)
        bgSteps[4].deltaCount = Math.floor(Math.random() * bgSteps[4].end)
        bgSteps[5].deltaCount = Math.floor(Math.random() * bgSteps[5].end)
        bgSteps[6].deltaCount = Math.floor(Math.random() * bgSteps[6].end)
        bgSteps[7].deltaCount = Math.floor(Math.random() * bgSteps[7].end)
        bgSteps[8].deltaCount = Math.floor(Math.random() * bgSteps[8].end)
        bgSteps[9].deltaCount = Math.floor(Math.random() * bgSteps[9].end)
        bgSteps[10].deltaCount = Math.floor(Math.random() * bgSteps[10].end)
    
        bgVectors.push(fiveVecs(bgStarts[0],fiveBelow(), bgSteps[0].end))
        bgVectors.push(fiveVecs(bgStarts[1],fiveBelow(), bgSteps[1].end))
        bgVectors.push(fiveVecs(bgStarts[2],fiveBelow(), bgSteps[2].end))
        bgVectors.push(fiveVecs(bgStarts[3],fiveBelow(), bgSteps[3].end))
        bgVectors.push(fiveVecs(bgStarts[4],fiveBelow(), bgSteps[4].end))
        bgVectors.push(fiveVecs(bgStarts[5],fiveBelow(), bgSteps[5].end))
        bgVectors.push(fiveVecs(bgStarts[6],fiveBelow(), bgSteps[6].end))
        bgVectors.push(fiveVecs(bgStarts[7],fiveBelow(), bgSteps[7].end))
        bgVectors.push(fiveVecs(bgStarts[8],fiveBelow(), bgSteps[8].end))
        bgVectors.push(fiveVecs(bgStarts[9],fiveBelow(), bgSteps[9].end))
        bgVectors.push(fiveVecs(bgStarts[10],fiveBelow(), bgSteps[10].end))
        
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
        bgColors.push(pastels[Math.floor(Math.random()*7)])
    
    }
    
    //console.log(bgSteps) 
    
    for(var i = 0; i < bgStarts.length; i++){

    
        if(bgSteps[i].deltaCount == bgSteps[i].end){ // if it's reached the target make a new one
            
            bgStarts[i]  = fiveAbove()
            bgSteps[i]   = {deltaCount:0,end:Math.floor(Math.random() * 1500 + 1500)}
            bgVectors[i] = fiveVecs(bgStarts[i],fiveBelow(), bgSteps[i].end)
            bgColors[i]  = pastels[Math.floor(Math.random()*5)]
        
        }
        
        if(shape == i){
    
            currentPos = [  {x:bgStarts[i][0].x + bgVectors[i][0].x * bgSteps[i].deltaCount, y:bgStarts[i][0].y + bgVectors[i][0].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][1].x + bgVectors[i][1].x * bgSteps[i].deltaCount, y:bgStarts[i][1].y + bgVectors[i][1].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][2].x + bgVectors[i][2].x * bgSteps[i].deltaCount, y:bgStarts[i][2].y + bgVectors[i][2].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][3].x + bgVectors[i][3].x * bgSteps[i].deltaCount, y:bgStarts[i][3].y + bgVectors[i][3].y * bgSteps[i].deltaCount} ] 
                            
                            /*,
                            {x:bgStarts[i][4].x + bgVectors[i][4].x * bgSteps[i].deltaCount, y:bgStarts[i][4].y + bgVectors[i][4].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][5].x + bgVectors[i][5].x * bgSteps[i].deltaCount, y:bgStarts[i][5].y + bgVectors[i][5].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][6].x + bgVectors[i][6].x * bgSteps[i].deltaCount, y:bgStarts[i][6].y + bgVectors[i][6].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][7].x + bgVectors[i][7].x * bgSteps[i].deltaCount, y:bgStarts[i][7].y + bgVectors[i][7].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][8].x + bgVectors[i][8].x * bgSteps[i].deltaCount, y:bgStarts[i][8].y + bgVectors[i][8].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][9].x + bgVectors[i][9].x * bgSteps[i].deltaCount, y:bgStarts[i][9].y + bgVectors[i][9].y * bgSteps[i].deltaCount},
                            {x:bgStarts[i][10].x + bgVectors[i][10].x * bgSteps[i].deltaCount, y:bgStarts[i][10].y + bgVectors[i][10].y * bgSteps[i].deltaCount} ] */
        
            ctx4.beginPath()
            
            roundedPoly(ctx4, currentPos, circleSize/20)
            
            ctx4.fillStyle = bgColors[i]
            ctx4.fill()
        
        }
        
        bgSteps[i].deltaCount += 1

    }    
    
}

function fiveAbove(){
    return [{x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height} ]
            
            /*,
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:(Math.random() -1) * height}]*/

}

function fiveBelow(){
    return [{x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height} ] 
            
            /*,
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height},
            {x:(Math.random() -.5) * 2 * width + (width/2),y:Math.random() * height + height}]*/
}
function fiveVecs(start, target, steps){

    return [{x: (target[0].x - start[0].x)/steps, y: (target[0].y - start[0].y)/steps},
            {x: (target[1].x - start[1].x)/steps, y: (target[1].y - start[1].y)/steps},
            {x: (target[2].x - start[2].x)/steps, y: (target[2].y - start[2].y)/steps},
            {x: (target[3].x - start[3].x)/steps, y: (target[3].y - start[3].y)/steps} ] 
            
            /*,
            {x: (target[4].x - start[4].x)/steps, y: (target[4].y - start[4].y)/steps},
            {x: (target[5].x - start[5].x)/steps, y: (target[5].y - start[5].y)/steps},
            {x: (target[6].x - start[6].x)/steps, y: (target[6].y - start[6].y)/steps},
            {x: (target[7].x - start[7].x)/steps, y: (target[7].y - start[7].y)/steps},
            {x: (target[8].x - start[8].x)/steps, y: (target[8].y - start[8].y)/steps},
            {x: (target[9].x - start[9].x)/steps, y: (target[9].y - start[9].y)/steps},
            {x: (target[10].x - start[10].x)/steps, y: (target[10].y - start[10].y)/steps}] */

}

function drawSmoke(){

    ctx3.clearRect(0,0,canvas1.width,canvas1.height)

    if(smokeFrame == 0){
    
        
        smokeList = []
    
        for(var i = 0; i < pops.length; i++){
            if(pops[i] == 1){
                particleList = []
                
                var color = getColor(values[i])[0]
                var color2 = getColor(values[i]/3)[0]
                for(var j = 0; j < 40; j++){
                
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize),
                                                    posY[i] +((Math.random() -.5) *circleSize),
                                                    Math.random()* height/60, 
                                                    color, 1.03))       
                                                    
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize),
                                                    posY[i] +((Math.random() -.5) *circleSize),
                                                    Math.random()* height/60, 
                                                    '#fff', 1.03))
                                                                                 
                }
                for(var j = 0; j < 6; j++){
                
                    particleList.push(new Particle( posX[i] + ((Math.random() -.5) *circleSize * 1.3),
                                                    posY[i] +((Math.random() -.5) *circleSize * 1.3) ,
                                                    Math.random()* 30, 
                                                    '#fa0', .94))
                }
                
                smokeList.push(particleList.slice())
            }
        }
    }
    
    //console.log(smokeList)
    
    for(var i = 0; i < smokeList.length; i++){
        //console.log(i)
        for(var j = 0; j < smokeList[i].length; j++){
        
            //console.log(smokeList[i][j])
        
            smokeList[i][j].move()
            //smokeList[i][j].move()
            //smokeList[i][j].move()
            //smokeList[i][j].move()
            smokeList[i][j].draw(ctx3)
        }
    }


}

function checkGameOver(){
    
    var slide = 0
  
    slide += checkCol(colR1)
    slide += checkCol(colR2)
    slide += checkCol(colR3)
    slide += checkCol(colR4)
    slide += checkCol(colR5)
    slide += checkCol(colG1)
    slide += checkCol(colG2)
    slide += checkCol(colG3)
    slide += checkCol(colG4)
    slide += checkCol(colG5)
    slide += checkCol(colB1)
    slide += checkCol(colB2)
    slide += checkCol(colB3)
    slide += checkCol(colB4)
    slide += checkCol(colB5)
    
    //console.log("slide from checklose:" + slide.toString())
    
    if(slide){
        return false
    } else {
        return true
    }
}

function youWin(){

    won = true
    var winDiv = document.getElementById("youWin");
    var innerDiv = document.getElementById("inner1");
    inner1.innerText =" You Won!"
    winDiv.style.display = 'inline-block'
    
}

function continueGame(){

    var winDiv = document.getElementById("youWin");
    winDiv.style.display = 'none'
    prompt = false

}

function gameOver(){

    var overDiv = document.getElementById("gameOver");
    var innerDiv = document.getElementById("inner1");
    innerDiv.innerText ="Game over! Your score is "+ score.toString() + "."
    overDiv.style.display = 'inline-block'

}

function toClipboard(print_score){

    text = text_board()

    if(print_score){
        text +=  "Score: " + score + "\n"      
    } else {
        var runDate = Date.now() - startDate 
        text += "Time: " + formatTime(secs2Time((runDate)/1000)) + "\n"
    }

    text += "https://nathan-sixnines.github.io/729"

    navigator.clipboard.writeText(text)
    setTimeout(function() { alert('Copied to clipboard'); }, 1);
}

function newGame(){

    games += 1

    nextValues.fill(0)
    
    score = 0
    
    ctx4.clearRect(0,0,width,height)
    
    addRandom()
    addRandom()
    
    values = nextValues.slice()
    
    prompt = false
    update = true
    
    var overDiv = document.getElementById("gameOver");
    overDiv.style.display = 'none'

}

// jsperf.com javascript performance website

function checkCol(col){

    var check = 0
    var count = 0
    
    var maxCount = 0
    
    for(var i = 0; i < col.length; i++){
        var val = values[col[i]]
        
        if(val == check){
            count += 1
        } else {
            count = 1
            check = val
        }
        
        if(count > maxCount){
        
            maxCount = count
        
        }
        
        if(count == 3){
            return true
        }
    }
    return false
}

function slideCol(col, up){

    //console.log('slide col')

    var slide = false   // this one we return an allows us to keep track if anything slid at all

    var runValue = 0
    var run      = 0
    
    if(! up){
        col = col.slice().reverse()  // don't want to reverse original list
    }
    
    var outCol        = []
    var slideStarts   = []
    var targetMarker  = 0   // index of where slides target
   
    //console.log("col")
    //console.log(col)
    
    var zeroGap = false
    
    for(var i = 0; i < col.length; i++){
    
        //console.log(outCol)
    
        var value = values[col[i]]
        
        //console.log("value:    " + value.toString())
        //console.log("runValue: " + runValue.toString())
        //console.log("run:      " + run.toString())
        
        if(value == 0){
            zeroGap = true
        } else {
        
            if(zeroGap){
                slide = true
            }
        
            if(value == runValue){
                run = run + 1
                if(run == 2){
                    slides[col[i]] = col[targetMarker]
                    slideStarts.push(col[i])
                    targetMarker = targetMarker + 1
                    outCol.push(value)
                }
                
                else if(run == 3){
                    slide = true
                
                    runValue = 0
                    run      = 0
                    outCol.pop(value)
                    outCol.pop(value)
                    outCol.push(value * 3)
                    score += value * 3
                    targetMarker = targetMarker - 2
                  
                    slides[col[i]]    = col[targetMarker]
                    slides[slideStarts[0]] = col[targetMarker]
                    //slides[slideStarts[1]] = col[targetMarker]
                    pops[col[targetMarker]] = 1
                    
                    targetMarker = targetMarker + 1
                    slideStarts = []                  
                }
            }
            
            else{
            
                slideStarts = []
                slides[col[i]] = col[targetMarker]
                targetMarker = targetMarker + 1
                outCol.push(value)
                
                runValue   = value
                run        = 1

            }
        }
    }
    
    for(var i = 0; i < col.length; i++){
    
        if(i < outCol.length){
            nextValues[col[i]] = outCol[i]
        }   else {
            nextValues[col[i]] = 0
        }
        
    }
    
    if(slide){
        return 1
    }
    else {
        return 0
    }
}

function addRandom(){

    //console.log('adding random')
    var pickList = []

    for(var i = 0; i < values.length; i++){
        if(nextValues[i] == 0){
            pickList.push(i)
        }
    }

    var pick = pickList[Math.floor(rand()*pickList.length)];
    
    if(Math.random() > 5/9){
        //if(mod(games,2)== 0){
            nextValues[pick] = 9
        //} else {
        //    nextValues[pick] = 3
        //}
    } else {
            nextValues[pick] = 3    
    }
    //nextValues[0] = 3
  
}

function slideR(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        pops   = new Array(19).fill(0)
        
        var a  = slideCol(colR1,up)
        var b  = slideCol(colR2,up)
        var c  = slideCol(colR3,up)
        var d  = slideCol(colR4,up)
        var e  = slideCol(colR5,up)
        
        if(a+b+c+d+e > 0){
            addRandom()
        }
        update = true
        first = false  
        animate()
    }
}
function slideG(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index(old values) to target position index
        pops   = new Array(19).fill(0)
        
        var a  = slideCol(colG1,up)
        var b  = slideCol(colG2,up)
        var c  = slideCol(colG3,up)
        var d  = slideCol(colG4,up)
        var e  = slideCol(colG5,up)
        
        var sum = a+b+c+d+e
        if(sum > 0){
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}
function slideB(up){
    if(!prompt && step == 0){
        nextValues = values.slice()
        slides = new Array(19).fill(-1)  // slides go from current position index (old values) to target position index
        pops   = new Array(19).fill(0)
        
        var a  = slideCol(colB1,up)
        var b  = slideCol(colB2,up)
        var c  = slideCol(colB3,up)
        var d  = slideCol(colB4,up)
        var e  = slideCol(colB5,up)
        if(a+b+c+d+e > 0){
            addRandom()
        }
        update = true
        first = false
        animate()
    }
}



// direction codes :
// up right   = 0   
// up left    = 1
// left       = 2
// down left  = 3
// down right = 4
// right      = 5


function animate(){

    slideValue  = []
    slide       = false
    
    slideStartX = []
    slideStartY = []
    
    deltaX = []
    deltaY = []

    for (var i = 0; i < slides.length; i++){
        if(slides[i] != -1){
              
            slideStartX.push(posX[i])
            slideStartY.push(posY[i])
            
            diffX = (posX[slides[i]] - posX[i]) / steps   // subtract original location from target
            diffY = (posY[slides[i]] - posY[i]) / steps   // because we want to end up at target by adding it back 
            
            deltaX.push(diffX)
            deltaY.push(diffY)
            
            slideValue.push(values[i])
            
        }
    }
    
    slide = true

}


// w = 87
// e = 69
// d = 68
// x = 88
// z = 90
// a = 65

document.onkeydown = function(e) {
    if(! update){
        actionByKeyCode(e.keyCode)
    }
    else{
        actionQueue.push(e.keyCode)
    }
}

function actionByKeyCode(code){
    switch (code) {
        case 87: // w
            slideB(false)
            break
        case 69: // e
            slideR(true)
            break    
        case 68: // d
            slideG(true)
            break
        case 88: // x
            slideB(true)
            break
        case 90: // z
            slideR(false)
            break
        case 65: // a
            slideG(false)
            break
    }
}

document.getElementById("container").addEventListener('mousedown', handleClickDown, false)
document.getElementById("container").addEventListener('mouseup', handleClickUp, false)
document.getElementById("container").addEventListener('mousemove', mouseMove, false)


var click = false
var xDownClick = null;                                                        
var yDownClick = null;

function handleClickDown(evt){

    xDownClick = evt.pageX - canvas1.offsetLeft;
    yDownClick = evt.pageY - canvas1.offsetTop;
    click = true

}

function handleClickUp(evt){
    click = false  
}

function mouseMove(evt){
    if(click){
        x2 = evt.pageX - canvas1.offsetLeft;
        y2 = evt.pageY - canvas1.offsetTop;

        var distance = Math.sqrt(Math.pow(x2 - xDownClick,2) + Math.pow(y2 - yDownClick,2))
        if( distance > height /20){
        
            var xDiff =  xDownClick - x2
            var yDiff =  yDownClick - y2
            
            diffSwipe(xDiff,yDiff)
            
            click = false
            xDownClick = null;                                                        
            yDownClick = null;
        }
    }
}

document.addEventListener('touchstart', handleTouchStart, false);        

document.addEventListener('touchmove', function(evt) {
    // I hate safari
    var userAgent = window.navigator.userAgent;
    var isSafari = (userAgent.match(/iPad/i) || userAgent.match(/iPhone/i))
    if (isSafari){
        evt.preventDefault();
    }
    handleTouchMove(evt)
})



document.addEventListener("resize", initCanvas);

var xDown = null;                                                        
var yDown = null;

function getTouches(evt) {
  return evt.touches ||             // browser API
         evt.originalEvent.touches; // jQuery
}                                                     

function handleTouchStart(evt) {                                         
    xDown = getTouches(evt)[0].clientX;                                      
    yDown = getTouches(evt)[0].clientY;                                      
};                                                

function handleTouchMove(evt) {

    if ( ! xDown || ! yDown ) {
        return;
    }

    var xUp = evt.touches[0].clientX;                                    
    var yUp = evt.touches[0].clientY;

    var xDiff = xDown - xUp;  // Think this is actually backwards but I fixed it to work on the other side
    var yDiff = yDown - yUp;    
    
    diffSwipe(xDiff, yDiff)
    
    /* reset values */
    xDown = null;
    yDown = null;                                             
};

function diffSwipe(xDiff, yDiff){

    var rad = (Math.atan2(yDiff, xDiff) / Math.PI) + 1;
    
    //ctx1.fillText(rad, 500,500)
    
    //console.log(rad)
    
    if(rad > (1/6) && rad <= (3/6)){
    //console.log('e , rad > 1/6 && rad <= 3/6, rad: ' + rad.toString())
    // e
    slideB(true)
    }
    else if(rad > (1/2) && rad <= (5/6)){
    //console.log('w , rad > 1/2 && rad <= 5/6, rad: ' + rad.toString())
    // w
    slideR(false)
    }
    else if(rad > (5/6) && rad <= (7/6)){
    //console.log('a , rad > 5/6 && rad <= 7/6, rad: ' + rad.toString())
    // a
     slideG(false)
    }
    else if(rad > (7/6) && rad <= (9/6)){
    //console.log('z , rad > 7/6 && rad <= 9/6, rad: ' + rad.toString())
    // z
    slideB(false)
    }
    else if(rad > (9/6) && rad <= (11/6)){
    //console.log('x , rad > 9/6 && rad <= 11/6, rad: ' + rad.toString())
    //  x
    slideR(true)
    }else{
    //console.log('d , other rad,                rad: ' + rad.toString())
    // d
    slideG(true)
    }


}

//console.log(canvas1)

initCanvas()



for(var i = 0; i < 19; i++){  //posX.length
   
    hexagon(posX[i], posY[i], ctx2, values[i])// + "|" + i.toString()) //values[i])
   
}

//drawBackground()

addRandom()
addRandom()

//nextValues[0] = 1
//nextValues[1] = 2
//nextValues[4] = 3
//nextValues[8] = 4

values = nextValues.slice()
update = true
drawLoop()
//console.log(values
	
console.log('hello logcat??')

</script>
